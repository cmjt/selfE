---
title: ""
output: 
  md_document:
    variant: markdown_github
---

```{r setup, include=FALSE,message=FALSE,results='asis'}
knitr::opts_chunk$set(echo = TRUE, eval = TRUE,cache = TRUE, message = FALSE,warning=FALSE)
library(kableExtra)
```
To install the `R` packahe `stelfi` run `devtools::install_github("cmjt/stelfi")`.

```{r lib}
library(stelfi)
```

# NZ murders

## The Data

```{r data}
data(murders_nz)
dim(murders_nz)
head(murders_nz)
```

```{r eda, echo = FALSE,results='asis'}
kable(table(murders_nz$Cause_cat), format = "pipe",col.names = c("Cause","Number"),caption = "Number of murders by category")
kable(table(murders_nz$Year),format = "pipe", col.names = c("Year","Number"),caption = "Number of murders by year")
kable(table(murders_nz$Region), format = "pipe", col.names = c("Region","Number"),caption = "Number of murders by province") 
```

```{r rate}
data(nz) ## SpatialPolygonsDataFrame of NZ (NZTM projection)
area_nz <- sum(raster::area(nz)) ## (m)
area_nzkm2 <- area_nz/1000^2 ## according to Google NZ is 268,021 km2
area_nzkm2
spatial_murder_rate <- nrow(murders_nz)/area_nzkm2 
temporal_murder_rate <- nrow(murders_nz)/length(table(murders_nz$Year)) 
st_murder_rate <- (nrow(murders_nz)/area_nzkm2)/length(table(murders_nz$Year)) 
```

Rate of murders per $\text{km}^2$ across NZ is calculated as `r round(spatial_murder_rate,4)`; there are roughly `r round(temporal_murder_rate,3)`. The spatio-temporal murder rate across NZ 2004--2019 is `r round(st_murder_rate,5)` (rate per $\text{km}^2$ per year).

### Transform to NZTM

Transform `data.frame` to `SpatialPointsDataFrame`

```{r sp}
murders_sp <- murders_nz
## project longitude & latitude to NZTMs
coordinates(murders_sp) <- c("Longitude","Latitude")
proj4string(murders_sp) <- CRS("+proj=longlat +datum=WGS84")
murders_sp <-  spTransform(murders_sp, 
                           CRS("+proj=nzmg +lat_0=-41.0 +lon_0=173.0 +x_0=2510000.0 +y_0=6023150.0 +ellps=intl +units=m"))
```

```{r plot,results='asis',fig.width=10,fig.height=10,echo = FALSE,warning=FALSE,message=FALSE}
plot(murders_sp)
plot(nz, add = TRUE)
```
*Locations of recorded (n = 967) murders in NZ 2004--2019*

## log-Gaussian Cox process

### Using INLA

**Steps below closely follow this [INLA-SPDE tutorial](https://becarioprecario.bitbucket.io/spde-gitbook/ch-lcox.html)**.


#### Creating the mesh

Typically when analysing point pattern data the point locations are not specified as the mesh nodes (i.e., locations are not given as an argument to `inla.mesh.2d()`). Instad we can supply the coordinates of the point pattern window (domain).

```{r create mesh}
mesh <- inla.mesh.2d(loc.domain = coordinates(nz) ,
                     max.edge = c(86000, 100000), cutoff = 5000)
```

 The SPDE approach for point pattern analysis defines the model at the nodes of the mesh. To fit the log-Cox point process model these points are considered as integration points. The method in Simpson et al. (2016) defines the expected number of events to be proportional to the area around the node (the areas of the polygons in the dual mesh, see below). This means that at the nodes of the mesh with larger triangles, there are also larger expected values.

```{r dual mesh,cache = TRUE,message = FALSE, fig.width=10,fig.height=10}
weights <- stelfi::get_weights(mesh = mesh, sp = nz, plot = TRUE)
## these weights are the areas of each mesh triangle,
## required for the "exposure" aspect of the LGCP.
## the weights are set to zero if outside the study region
## as here the they should have no contribution. 
## the sum of the weights is the area of the study region
```
*Delauney triangulation of the domain (white) overlain on the Voronoi diagram representing the weights (area surrounding) of each mesh node (diamonds). Observations are plotted as circles, mesh nodes outwith the domain are shown in white.*


```{r plot weights,echo = FALSE, fig.width=10,fig.height=10}
## function below is a wrapper for
## the book.dual.mesh() function supplied
## in the INLA-SPDE tutorial mentioned above
dual_mesh <- stelfi:::inla.mesh.dual(mesh)
## expected number per mesh node
ins <- which(weights != 0)
pal <- scales::col_numeric("Blues",weights[ins])
cols <- pal(weights[ins])
plot(dual_mesh[ins], col = cols)
plot(nz, add = TRUE)
fields::image.plot(zlim = range(weights[ins]/1000^2),col = sort(cols, TRUE), legend.only = TRUE, legend.width = 2, nlevel = 10, legend.shrink = 0.5)
```
*Voronoi diagram of the weights (areas in km2 around each mesh node).*

#### Spatial only LGCP

```{r model fitting}
## number of mesh nodes
nodes <- mesh$n
## define model
spde <- inla.spde2.pcmatern(mesh = mesh,
  # PC-prior on range: P(practic.range < 0.05) = 0.01
  prior.range = c(0.05, 0.01),
  # PC-prior on sigma: P(sigma > 1) = 0.01
  prior.sigma = c(1, 0.01))
## vector for observations
y.pp <- rep(0:1, c(nodes, nrow(murders_sp)))
## exposure (E)
e.pp <- c(weights, rep(0, nrow(murders_sp)))
## integration points
imat <- Diagonal(nodes, rep(1, nodes))
## projection matrix for observed points
lmat <- inla.spde.make.A(mesh, coordinates(murders_sp))
## entire projection matrix
A.pp <- rbind(imat, lmat)
## data stack
stk.pp <- inla.stack(
  data = list(y = y.pp, e = e.pp), 
  A = list(1, A.pp),
  effects = list(list(b0 = rep(1, nodes + nrow(murders_sp))), 
                 list(i = 1:nodes)),
  tag = 'pp')
## fit model
pp.res <- inla(y ~ 0 + b0 + f(i, model = spde), 
  family = 'poisson', data = inla.stack.data(stk.pp), 
  control.predictor = list(A = inla.stack.A(stk.pp)), 
  E = inla.stack.data(stk.pp)$e)
## fixed effects
pp.res$summary.fixed
## expected number of murders at each mesh node
ins <- which(weights != 0)
en <- exp(as.numeric(pp.res$summary.fixed[1]))*weights[ins]
sum(en) ## expected number across NZ, observed 967
```

```{r inference,echo = FALSE, fig.width=15,fig.height=15}
## expected number per mesh node
fields <- stelfi::get_fields(pp.res, mesh)
response <-  exp(fields[[1]][ins] + as.numeric(pp.res$summary.fixed[1]))*weights[ins]
pal <- scales::col_numeric("Blues", response)
cols <- pal(response)
plot(dual_mesh[ins], col = cols)
plot(nz, add = TRUE)
fields::image.plot(zlim = range(exp(as.numeric(pp.res$summary.fixed[1]))*weights[ins]),
                   col = sort(cols, TRUE), legend.only = TRUE, 
                   legend.width = 2, nlevel = 10, legend.shrink = 0.5)
```
*Voronoi diagram of the expected number of murders per mesh node.*

```{r resp,echo = FALSE, fig.width=15,fig.height=15}
## projected
resp <- exp(fields[[1]] + as.numeric(pp.res$summary.fixed[1]))*weights
show_field(resp, mesh, dims = c(300,300),
		 col = RColorBrewer::brewer.pal(9, "Blues"), sp = nz,
           	 rast = FALSE, legend = TRUE, FALSE)
```
*Voronoi diagram of the expected number of murders per mesh node.*

##### Adding a covariate

```{r}
## include covariates
## The covariate shapefile used can be downloaded from
## https://koordinates.com/layer/7322-new-zealand-population-density-by-meshblock/
## the code below assumes a single .shp (above) file is
## in a directory data/ relative to your working directory
file <- list.files("data",pattern = ".shp", full = TRUE)
layer <- rgdal::ogrListLayers(file)
pop <- rgdal::readOGR(file, layer = layer)
pop <- spTransform(pop, CRS("+proj=nzmg +lat_0=-41.0 +lon_0=173.0 +x_0=2510000.0 +y_0=6023150.0 +ellps=intl +units=m"))
pop_mesh <- sp::over(SpatialPoints(mesh$loc[,1:2], proj4string = CRS(proj4string(murders_sp))),pop)
## will obviously be NA at mesh nodes outside NZ
pop_obs <- sp::over(murders_sp,pop)
## population density covariate c at mesh nodes and then obs locations 
covs <- data.frame(pop = c(pop_mesh$pop_densit, pop_obs$pop_densit))
```

```{r fir cov model}
## data stack
stk.cov <- inla.stack(
  data = list(y = y.pp, e = e.pp), 
  A = list(1, A.pp),
  effects = list(list(b0 = rep(1, nodes + nrow(murders_sp)), pop = covs$pop), 
                 list(i = 1:nodes)),
  tag = 'pp')
## fit model
pp.cov <- inla(y ~ 0 + b0 + pop + f(i, model = spde), 
  family = 'poisson', data = inla.stack.data(stk.cov), 
  control.predictor = list(A = inla.stack.A(stk.cov)), 
  E = inla.stack.data(stk.pp)$e)
```

#### Spatio-tempoal LGCP

```{r st model,eval = FALSE, echo = TRUE}
## space time SPDE
## A set of knots over time needs to be defined in order to fit a
## SPDE spatio-temporal model. It is then used to build a temporal mesh, as follows:

## spatio temporal
k <- length(table(murders_sp$Year))
temp <- murders_sp$Year - min(murders_sp$Year) + 1
## tknots <- seq(min(data$Year), max(data$Year), length = k) ## don't need this as year already discrete
mesh.t <- inla.mesh.1d(1:k)
## spatial spde
spde <- inla.spde2.pcmatern(mesh = mesh,
  prior.range = c(5, 0.01), # P(practic.range < 5) = 0.01
  prior.sigma = c(1, 0.01)) # P(sigma > 1) = 0.01
m <- spde$n.spde
## spatio-temporal projection matrix
Ast <- inla.spde.make.A(mesh = mesh, loc = coordinates(murders_sp),
                        n.group = length(mesh.t$n), group = temp,
                        group.mesh = mesh.t)
## index set
idx <- inla.spde.make.index('s', spde$n.spde, n.group = mesh.t$n)
## spatio-temporal volume
st.vol <- rep(weights, k) * rep(diag(inla.mesh.fem(mesh.t)$c0), m)
y <- rep(0:1, c(k * m, nrow(murders_sp)))
expected <- c(st.vol, rep(0, nrow(murders_sp)))
stk <- inla.stack(
    data = list(y = y, expect = expected), 
    A = list(rbind(Diagonal(n = k * m), Ast), 1), 
    effects = list(idx, list(a0 = rep(1, k * m + nrow(murders_sp)))))
## formula
pcrho <- list(prior = 'pccor1', param = c(0.7, 0.7))
form <- y ~ 0 + a0 + f(s, model = spde, group = s.group, 
                       control.group = list(model = 'ar1',
                                            hyper = list(theta = pcrho)))
res <- inla(form, family = 'poisson', 
            data = inla.stack.data(stk), E = expect,
            control.predictor = list(A = inla.stack.A(stk)),
            control.inla = list(strategy = 'adaptive'))
## The exponential of the intercept plus the random effect at each space-time
## integration point is the relative risk at each of these points. This relative
## risk times the space-time volume will give the expected number of points (E(n))
## at each one of these space-time locations. Summing over them will give a value
## that approaches the number of observations:
eta.at.integration.points <- res$summary.fix[1,1] + res$summary.ran$s$mean
c(n = nrow(data), 'E(n)' = sum(st.vol * exp(eta.at.integration.points))) 
```

## Model fitting using `stelfi`

### As a wrapper for `INLA`

```{r using stelfi, eval = FALSE}
## Spatial only
fit <- fit_lgcp_inla(mesh = mesh, locs = coordinates(murders_sp), sp = nz)
summary(fit)
## Spatiotemporal
temp <- murders_sp$Year - min(murders_sp$Year) + 1
fit_temp <- fit_lgcp_inla(mesh = mesh, locs = coordinates(murders_sp), sp = nz,
	 temp = temp)
summary(fit_temp)
```

#### With a covariate

### Using `TMB` TODO

```{r using TMB}
## ensure you've run compile.stelfi()

```