---
title: ""
output: 
  md_document:
    variant: markdown_github
---

```{r setup, include=FALSE,message=FALSE,results='asis'}
knitr::opts_chunk$set(echo = TRUE, eval = TRUE,cache = TRUE, message = FALSE,warning=FALSE)
library(kableExtra)
```

```{r lib}
library(stelfi)
```

# NZ murders

## The Data

```{r data}
data(murders_nz)
dim(murders_nz)
head(murders_nz)
```

```{r eda, echo = FALSE,results='asis'}
kable(table(murders_nz$Cause_cat), format = "pipe",col.names = c("Cause","Number"),caption = "Number of murders by category")
kable(table(murders_nz$Year),format = "pipe", col.names = c("Year","Number"),caption = "Number of murders by year")
kable(table(murders_nz$Region), format = "pipe", col.names = c("Region","Number"),caption = "Number of murders by province") 
```

```{r rate}
data(nz) ## SpatialPolygonsDataFrame of NZ (NZTM projection)
area_nz <- sum(raster::area(nz)) ## (m)
area_nzkm2 <- area_nz/1000^2 ## according to Google NZ is 268,021 km2
spatial_murder_rate <- nrow(murders_nz)/area_nzkm2 
temporal_murder_rate <- nrow(murders_nz)/length(table(murders_nz$Year)) 
st_murder_rate <- (nrow(murders_nz)/area_nzkm2)/length(table(murders_nz$Year)) 
```

Rate of murders per $\text{km}^2$ across NZ is calculated as `r round(spatial_murder_rate,4)`; there are roughly `r round(temporal_murder_rate,3)`. The spatio-temporal murder rate across NZ 2004--2019 is `r round(st_murder_rate,5)` (rate per $\text{km}^2$ per year).

### Transform to NZTM

Transform `data.frame` to `SpatialPointsDataFrame`

```{r sp}
murders_sp <- murders_nz
## project longitude & latitude to NZTMs
coordinates(murders_sp) <- c("Longitude","Latitude")
proj4string(murders_sp) <- CRS("+proj=longlat +datum=WGS84")
murders_sp <-  spTransform(murders_sp, 
                           CRS("+proj=nzmg +lat_0=-41.0 +lon_0=173.0 +x_0=2510000.0 +y_0=6023150.0 +ellps=intl +units=m"))
```

```{r plot,results='asis',fig.width=10,fig.height=10,fig.cap="Locations of recorded (n = 967) murders in NZ 2004--2019",echo = FALSE,warning=FALSE,message=FALSE}
plot(murders_sp)
plot(nz, add = TRUE)
```

## log-Gaussian Cox process

### Using INLA

**Steps below closely follow this [INLA-SPDE tutorial](https://becarioprecario.bitbucket.io/spde-gitbook/ch-lcox.html)**.


#### Creating the mesh

Typically when analysing point pattern data the point locations are not specified as the mesh nodes (i.e., locations are not given as an argument to `inla.mesh.2d()`). Instad we can supply the coordinates of the point pattern window (domain).

```{r create mesh}
mesh <- inla.mesh.2d(loc.domain = coordinates(nz) ,
                     max.edge = c(86000, 100000), cutoff = 5000)
```

 The SPDE approach for point pattern analysis defines the model at the nodes of the mesh. To fit the log-Cox point process model these points are considered as integration points. The method in Simpson et al. (2016) defines the expected number of events to be proportional to the area around the node (the areas of the polygons in the dual mesh, see below). This means that at the nodes of the mesh with larger triangles, there are also larger expected values.

```{r dual mesh,cache = TRUE,message=FALSE}
## intersection between mesh and study area
weights <- stelfi:::get_weights(mesh, nz)
## these weights are the areas of each mesh triangle,
## required for the "exposure" aspect of the LGCP.
## the weights are set to zero if outside the study region
## as here the they should have no contribution. 
## the sum of the weights is the area of the study region
```


```{r plot dual mesh, echo = FALSE, fig.width=15,fig.height=15,fig.cap="Delauney triangulation of the domain (white) overlain on the Voronoi diagram representing the weights (area surrounding) of each mesh node (diamonds). Observations are plotted as circles, mesh nodes outwith the domain are shown in grey."}
## function below is a wrapper for
## the book.dual.mesh() function supplied
## in the INLA-SPDE tutorial mentioned above
dual_mesh <- stelfi:::inla.mesh.dual(mesh)
plot(dual_mesh, col = "grey")
plot(mesh, add = TRUE, edge.color = "white")
points(murders_sp, pch = 20)
plot(nz,add = TRUE)
points(mesh$loc,pch = 18)
points(mesh$loc[weights == 0,],col = "grey", pch = 18)
```

```{r plot weights,echo = FALSE, fig.width=15,fig.height=15,fig.cap="Voronoi diagram of the weights (areas in km2 around each mesh node)."}
## expected number per mesh node
ins <- which(weights != 0)
pal <- scales::col_numeric("Blues",weights[ins])
cols <- pal(weights[ins])
plot(dual_mesh[ins], col = cols)
plot(nz, add = TRUE)
fields::image.plot(zlim = range(weights[ins]/1000^2),col = sort(cols, TRUE), legend.only = TRUE, legend.width = 2, nlevel = 10, legend.shrink = 0.5)
```


#### Spatial only LGCP

```{r model fitting}
## number of mesh nodes
nodes <- mesh$n
## define model
spde <- inla.spde2.pcmatern(mesh = mesh,
  # PC-prior on range: P(practic.range < 0.05) = 0.01
  prior.range = c(0.05, 0.01),
  # PC-prior on sigma: P(sigma > 1) = 0.01
  prior.sigma = c(1, 0.01))
## vector for observations
y.pp <- rep(0:1, c(nodes, nrow(murders_sp)))
## exposure (E)
e.pp <- c(weights, rep(0, nrow(murders_sp)))
## integration points
imat <- Diagonal(nodes, rep(1, nodes))
## projection matrix for observed points
lmat <- inla.spde.make.A(mesh, coordinates(murders_sp))
## entire projection matrix
A.pp <- rbind(imat, lmat)
## data stack
stk.pp <- inla.stack(
  data = list(y = y.pp, e = e.pp), 
  A = list(1, A.pp),
  effects = list(list(b0 = rep(1, nodes + nrow(murders_sp))), 
                 list(i = 1:nodes)),
  tag = 'pp')
## fit model
pp.res <- inla(y ~ 0 + b0 + f(i, model = spde), 
  family = 'poisson', data = inla.stack.data(stk.pp), 
  control.predictor = list(A = inla.stack.A(stk.pp)), 
  E = inla.stack.data(stk.pp)$e)
## fixed effects
pp.res$summary.fixed
## expected number of murders at each mesh node
en <- exp(as.numeric(pp.res$summary.fixed[1]))*weights[ins]
sum(en) ## expected number across NZ, observed 967
```

```{r inference,echo = FALSE, fig.width=15,fig.height=15,fig.cap="Voronoi diagram of the expected number of murders per mesh node."}
## expected number per mesh node
ins <- which(weights != 0)
pal <- scales::col_numeric("Blues",
                           exp(as.numeric(pp.res$summary.fixed[1]))*weights[ins]/1000^2)
cols <- pal(exp(as.numeric(pp.res$summary.fixed[1]))*weights[ins]/1000^2)
plot(dual_mesh[ins], col = cols)
plot(nz, add = TRUE)
fields::image.plot(zlim = range(exp(as.numeric(pp.res$summary.fixed[1]))*weights[ins]/1000^2),
                   col = sort(cols, TRUE), legend.only = TRUE, 
                   legend.width = 2, nlevel = 10, legend.shrink = 0.5)
```

#### Spatio-tempoal LGCP

```{r st model,eval = FALSE}
## space time SPDE
## A set of knots over time needs to be defined in order to fit a
## SPDE spatio-temporal model. It is then used to build a temporal mesh, as follows:

k <- length(table(data$Year))
## tknots <- seq(min(data$Year), max(data$Year), length = k) ## don't need this as year already discrete
mesh.t <- inla.mesh.1d(1:k)
## spatial spde
spde <- inla.spde2.pcmatern(mesh = mesh,
  prior.range = c(5, 0.01), # P(practic.range < 5) = 0.01
  prior.sigma = c(1, 0.01)) # P(sigma > 1) = 0.01
m <- spde$n.spde
## spatio-temporal projection matrix
Ast <- inla.spde.make.A(mesh = mesh, loc = locs[-968,],
                        n.group = length(mesh.t$n), group = temp,
                        group.mesh = mesh.t)
## index set
idx <- inla.spde.make.index('s', spde$n.spde, n.group = mesh.t$n)
## spatio-temporal volume
st.vol <- rep(w, k) * rep(diag(inla.mesh.fem(mesh.t)$c0), m)
y <- rep(0:1, c(k * m, nrow(data)))
expected <- c(st.vol, rep(0, nrow(data)))
stk <- inla.stack(
    data = list(y = y, expect = expected), 
    A = list(rbind(Diagonal(n = k * m), Ast), 1), 
    effects = list(idx, list(a0 = rep(1, k * m + nrow(data)))))
## formula
pcrho <- list(prior = 'pccor1', param = c(0.7, 0.7))
form <- y ~ 0 + a0 + f(s, model = spde, group = s.group, 
                       control.group = list(model = 'ar1',
                                            hyper = list(theta = pcrho)))
res <- inla(form, family = 'poisson', 
            data = inla.stack.data(stk), E = expect,
            control.predictor = list(A = inla.stack.A(stk)),
            control.inla = list(strategy = 'adaptive'))
## The exponential of the intercept plus the random effect at each space-time
## integration point is the relative risk at each of these points. This relative
## risk times the space-time volume will give the expected number of points (E(n))
## at each one of these space-time locations. Summing over them will give a value
## that approaches the number of observations:
eta.at.integration.points <- res$summary.fix[1,1] + res$summary.ran$s$mean
c(n = nrow(data), 'E(n)' = sum(st.vol * exp(eta.at.integration.points))) 
```