[["index.html", "Fitting models using stelfi Introduction Installing stelfi", " Fitting models using stelfi Introduction Installing stelfi The stelfi package can be installed from Github: devtools::install_github(&quot;cmjt/stelfi&quot;) Compiling templates Before using the TMB templates in stelfi you should use compile_stelfi() to compile them: library(stelfi) compile_stelfi() "],["hawkes.html", "Chapter 1 Hawkes process 1.1 The fit_hawkes() function 1.2 The fit_hawkes_cbf() function", " Chapter 1 Hawkes process A univariate Hawkes process is defined to be a self-exciting temporal point process where the conditional intensity function is given by \\[\\lambda(t) = \\mu(t) + \\Sigma_{i:\\tau_i&lt;t}\\nu(t-\\tau_i)\\] where where \\(\\mu(t)\\) is the background rate of the process and \\(\\Sigma_{i:\\tau_i&lt;t}\\nu(t-\\tau_i)\\) is some historic temporal dependence. First introduced by Hawkes (1971) \\[\\lambda(t) = \\mu(t) + \\alpha \\Sigma_{i:\\tau_i&lt;t}\\text{exp}(-\\beta * (t-\\tau_i)) \\] 1.1 The fit_hawkes() function ## devtools::load_all(&quot;~/Git/stelfi&quot;) library(stelfi) args(fit_hawkes) ## function (times, parameters, model = 1, marks = c(rep(1, length(times))), ## tmb_silent = TRUE, optim_silent = TRUE, ...) ## NULL Retweets A NIWA scientist found a working USB in the scat of a leopard seal, they then tweeted about it in the hopes of finding its owner. data(retweets_niwa) head(retweets_niwa) ## [1] &quot;2019-02-07 06:50:08 UTC&quot; &quot;2019-02-07 06:50:08 UTC&quot; ## [3] &quot;2019-02-07 06:49:22 UTC&quot; &quot;2019-02-07 06:48:48 UTC&quot; ## [5] &quot;2019-02-07 06:47:52 UTC&quot; &quot;2019-02-07 06:47:42 UTC&quot; ## numeric time stamps times &lt;- unique(sort(as.numeric(difftime(retweets_niwa ,min(retweets_niwa),units = &quot;mins&quot;)))) (#fig:plot hist)Observed counts of retweet times. params &lt;- c(mu = 9, alpha = 3, beta = 10) ## must have compiled TMB templates first use compile_stelfi() fit &lt;- fit_hawkes(times = times,parameters = params) ## print out estimated parameters pars &lt;- get_coefs(fit) pars ## Estimate Std. Error ## mu 0.06328099 0.017783908 ## alpha 0.07596531 0.007777899 ## beta 0.07911346 0.008109789 show_hawkes(times = times, mu = pars[1,1], alpha = pars[2,1], beta = pars[3,1]) show_hawkes_GOF(times = times, mu = pars[1,1], alpha = pars[2,1], beta = pars[3,1], return_values = FALSE) ETAS marked model Here we fit a univariate marked Hawkes process where the conditional intensity function is given by \\[\\lambda(t; m(t)) = \\mu(t) + \\alpha \\Sigma_{i:\\tau_i&lt;t}m(t-\\tau_i)\\text{exp}(-\\beta * (t-\\tau_i)) \\] where \\(\\mu(t)\\) is the background rate of the process, \\(m(t)\\) is the temporal mark and \\(\\Sigma_{i:\\tau_i&lt;t}\\nu(t-\\tau_i)\\) is some historic temporal dependence. data(&quot;earthquakes&quot;) head(earthquakes) ## origintime longitude latitude magnitude depth ## 1 2014-12-24 07:46:00 172.7133 -43.57944 3.208996 13.671875 ## 2 2014-12-24 06:43:00 172.7204 -43.55752 4.109075 5.820312 ## 3 2014-12-14 08:53:00 172.3641 -43.62563 3.240377 5.058594 ## 4 2014-12-12 13:37:00 172.3680 -43.63492 4.459034 9.394531 ## 5 2014-11-20 08:24:00 172.7836 -43.42493 3.116447 10.039062 ## 6 2014-11-18 14:19:00 172.7936 -43.48970 3.158710 11.269531 earthquakes &lt;- earthquakes[order(earthquakes$origintime),] earthquakes &lt;- earthquakes[!duplicated(earthquakes$origintime),] times &lt;- earthquakes$origintime times &lt;- as.numeric(difftime(times , min(times), units = &quot;mins&quot;)) marks &lt;- earthquakes$magnitude params &lt;- c(mu = 3, alpha = 0.05, beta = 1) ## must have compiled TMB templates first use compile_stelfi() fit &lt;- fit_hawkes(times = times, parameters = params, marks = marks) ## Warning: 2 external pointers will be removed ## print out estimated parameters pars &lt;- get_coefs(fit) pars ## Estimate Std. Error ## mu 0.0002001766 1.206014e-05 ## alpha 0.0005125373 2.934243e-05 ## beta 0.0020558328 1.204552e-04 show_hawkes(times = times, mu = pars[1,1], alpha = pars[2,1], beta = pars[3,1], marks = marks) show_hawkes_GOF(times = times, mu = pars[1,1], alpha = pars[2,1], beta = pars[3,1], marks = marks, return_values = FALSE) 1.2 The fit_hawkes_cbf() function args(fit_hawkes_cbf) ## function (times, parameters, model = 1, marks = c(rep(1, length(times))), ## background, background_integral, background_parameters, background_min, ## tmb_silent = TRUE, optim_silent = TRUE) ## NULL References "],["lgcp.html", "Chapter 2 log-Gaussian Cox Process 2.1 The fit_lgcp() function 2.2 Fitting a LGCP", " Chapter 2 log-Gaussian Cox Process 2.1 The fit_lgcp() function args(fit_lgcp) ## function (locs, sp, smesh, tmesh, parameters, covariates, tmb_silent = TRUE, ## nlminb_silent = TRUE, ...) ## NULL 2.2 Fitting a LGCP 2.2.1 Spatial only require(maptools) data(xyt, package = &quot;stelfi&quot;) domain &lt;- as(xyt$window, &quot;SpatialPolygons&quot;) locs &lt;- data.frame(x = xyt$x, y = xyt$y) smesh &lt;- INLA::inla.mesh.2d(boundary = INLA::inla.sp2segment(domain), max.edge = 0.75, cutoff = 0.3) system.time(fit &lt;- fit_lgcp(locs = locs, sp = domain, smesh = smesh, parameters = c(beta = 0, log_tau = log(1), log_kappa = log(1)))) ## user system elapsed ## 4.267 0.256 4.457 get_coefs(fit) ## Estimate Std. Error ## beta 2.4481848 0.09034657 ## log_tau -1.3156570 0.33288053 ## log_kappa 0.9547072 0.29440167 ## range 1.0887319 0.32052448 ## stdev 0.4047190 0.05027126 plot_lambda(fit, smesh = smesh, border = domain) + ggplot2::theme_void() Comparing to inlabru require(inlabru) require(ggplot2) matern &lt;- INLA::inla.spde2.matern(smesh) cmp &lt;- coordinates ~ mySmooth(coordinates, model = matern) + Intercept(1) coordinates(locs) &lt;- c(&quot;x&quot;, &quot;y&quot;) system.time(fit_inla &lt;- lgcp(cmp, locs, samplers = domain, domain = list(coordinates = smesh), options = list(control.inla = list(int.strategy = &quot;eb&quot;)))) ## user system elapsed ## 6.649 6.562 6.577 summary(fit_inla) ## inlabru version: 2.5.2 ## INLA version: 22.05.07 ## Components: ## mySmooth: Model types main=&#39;spde&#39;, group=&#39;exchangeable&#39;, replicate=&#39;iid&#39; ## Intercept: Model types main=&#39;linear&#39;, group=&#39;exchangeable&#39;, replicate=&#39;iid&#39; ## Likelihoods: ## Family: &#39;cp&#39; ## Data class: &#39;SpatialPointsDataFrame&#39; ## Predictor: coordinates ~ . ## Time used: ## Pre = 0.952, Running = 4.83, Post = 0.0843, Total = 5.86 ## Fixed effects: ## mean sd 0.025quant 0.5quant 0.975quant mode kld ## Intercept 2.487 0.14 2.213 2.487 2.762 NA 0.028 ## ## Random effects: ## Name Model ## mySmooth SPDE2 model ## ## Model hyperparameters: ## mean sd 0.025quant 0.5quant 0.975quant mode ## Theta1 for mySmooth -0.424 0.255 -0.914 -0.428 0.089 NA ## Theta2 for mySmooth 0.223 0.302 -0.385 0.228 0.804 NA ## ## Deviance Information Criterion (DIC) ...............: 5037.99 ## Deviance Information Criterion (DIC, saturated) ....: 173.34 ## Effective number of parameters .....................: 19.93 ## ## Watanabe-Akaike information criterion (WAIC) ...: 2895.65 ## Effective number of parameters .................: 808.56 ## ## Marginal log-Likelihood: -2555.64 ## is computed ## Posterior summaries for the linear predictor and the fitted values are computed ## (Posterior marginals needs also &#39;control.compute=list(return.marginals.predictor=TRUE)&#39;) 2.2.2 Spatiotemporal LGCP ndays &lt;- 2 locs &lt;- data.frame(x = xyt$x, y = xyt$y, t = xyt$t) w0 &lt;- 2 tmesh &lt;- INLA::inla.mesh.1d(seq(0, ndays, by = w0)) fit &lt;- fit_lgcp(locs = locs, sp = domain, smesh = smesh, tmesh = tmesh, parameters = c(beta = 0, log_tau = log(1), log_kappa = log(1), atanh_rho = 0.2)) get_coefs(fit) ## Estimate Std. Error ## rho 0.3100841 0.20738457 ## beta 1.6852264 0.13685036 ## log_tau -1.0683016 0.22402076 ## log_kappa 0.4785904 0.22707189 ## range 1.7526525 0.39797812 ## stdev 0.5087488 0.05765947 plot_lambda(fit, smesh = smesh, tmesh = tmesh, timestamp = 1, title = &quot;t = 1&quot;) + ggplot2::theme_void() plot_lambda(fit, smesh = smesh, tmesh = tmesh, timestamp = 2, title = &quot;t = 2&quot;) + ggplot2::theme_void() "],["references.html", "References", " References "]]
