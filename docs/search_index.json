[["index.html", "The R package stelfi Installation", " The R package stelfi Charlotte M. Jones-Todd &amp; Alec van Helsdingen Installation The development version of stelfi package can be installed from GitHub: devtools::install_github(&quot;cmjt/stelfi&quot;) The stelfi package requires installation of the non-CRAN package INLA. To install INLA use install.packages(&quot;INLA&quot;,repos=c(getOption(&quot;repos&quot;),INLA=&quot;https://inla.r-inla-download.org/R/stable&quot;), dep=TRUE) If you have any issues please follow these instructions. "],["data.html", "Chapter 1 Datasets in stelfi 1.1 Temporal point pattern data 1.2 Spatiotemporal point pattern data 1.3 Simulated data", " Chapter 1 Datasets in stelfi Below are the data packaged within stelfi. library(stelfi) data(package = &quot;stelfi&quot;)$result[, c(&quot;Item&quot;, &quot;Title&quot;)] ## Item Title ## [1,] &quot;horse_mesh&quot; &quot;Example Delaunay triangulation&quot; ## [2,] &quot;horse_sf&quot; &quot;Example &#39;sf&#39; &#39;POLYGON&#39;&quot; ## [3,] &quot;iraq_terrorism&quot; &quot;Terrorism in Iraq, 2013 - 2017&quot; ## [4,] &quot;marked&quot; &quot;Example marked point pattern data set&quot; ## [5,] &quot;nz_earthquakes&quot; &quot;Earthquakes in Canterbury, NZ, 2010 - 2014&quot; ## [6,] &quot;nz_murders&quot; &quot;Murders of NZ, 2004 - 2019&quot; ## [7,] &quot;retweets_niwa&quot; &quot;Retweets of NIWA&#39;s viral leopard seal Tweet&quot; ## [8,] &quot;sasquatch&quot; &quot;Sasquatch (bigfoot) sightings in the USA, 2000 - 2005&quot; ## [9,] &quot;uk_serial&quot; &quot;Serial killers of the UK, 1828 - 2015&quot; ## [10,] &quot;xyt&quot; &quot;Self-exciting point pattern&quot; 1.1 Temporal point pattern data ## load the tidyverse packages library(tidyverse) retweets_niwa In 2019 a NIWA scientist found a working USB in the scat of a leopard seal, they then tweeted about it in the hopes of finding its owner. In this chapter a Hawkes process is fitted to these data. NIWA is searching for the owner of a USB stick found in the poo of a leopard seal… Recognise this video? Scientists analysing the scat of leopard seals have come across an unexpected discovery – a USB stick full of photos &amp; still in working order! https://t.co/2SZVkm5az4 pic.twitter.com/JLEC8vuHH0&mdash; NIWA (@niwa_nz) February 5, 2019 The retweets_niwa dataset contains the retweet timestamps for this tweet. data(retweets_niwa, package = &quot;stelfi&quot;) head(retweets_niwa) ## [1] &quot;2019-02-07 06:50:08 UTC&quot; &quot;2019-02-07 06:50:08 UTC&quot; ## [3] &quot;2019-02-07 06:49:22 UTC&quot; &quot;2019-02-07 06:48:48 UTC&quot; ## [5] &quot;2019-02-07 06:47:52 UTC&quot; &quot;2019-02-07 06:47:42 UTC&quot; ggplot(data.frame(time = retweets_niwa), aes(x = time)) + geom_histogram() + ylab(&quot;Retweet frequency&quot;) + xlab(&quot;&quot;) + theme_bw() uk_serial Murder UK documents some of the UKs most infamous multiple murderer cases. The uk_serial dataset contains summary information about the documented cases along with approximate timeframes. data(&quot;uk_serial&quot;, package = &quot;stelfi&quot;) head(uk_serial) ## number_of_kills years name aka ## 1 300 1995 - 1998 Dr. Harold Shipman Dr. Death ## 2 160 1949 - 1983 Dr. John Bodkin Adams ## 3 26 1978 Peter Dinsdale Bruce Lee ## 4 21 1865 - 1872 Mary Ann Cotton ## 5 16 1828 William Burke and William Hare Body Snatchers ## 6 15 1944 - 1948 John George Haigh Acid Bath Murderer ## year_start year_end date_of_first_kill population_million ## 1 1995 1998 03/1995 58.02 ## 2 1949 1983 08/1949 50.32 ## 3 1973 NA 06/1973 56.19 ## 4 1865 1872 01/1865 24.36 ## 5 1828 NA 02/1828 15.73 ## 6 1944 1948 09/1944 49.02 uk_serial %&gt;% mutate(time = paste(date_of_first_kill, &quot;/01&quot;, sep=&#39;&#39;)) %&gt;% mutate(time = as.Date(time, &quot;%m/%Y/%d&quot;)) %&gt;% ggplot(aes(x = time)) + geom_histogram() + ylab(&quot;Frequency of known first kill&quot;) + xlab(&quot;&quot;) + theme_bw() 1.2 Spatiotemporal point pattern data Using maps to create sf objects of country boundaries: us &lt;- maps::map(&quot;usa&quot;, fill = TRUE, plot = FALSE) %&gt;% sf::st_as_sf() %&gt;% sf::st_make_valid() nz &lt;- maps::map(&quot;nz&quot;, fill = TRUE, plot = FALSE) %&gt;% sf::st_as_sf() %&gt;% sf::st_make_valid() iraq &lt;- maps::map(&quot;world&quot;, &quot;Iraq&quot;, fill = TRUE, plot = FALSE) %&gt;% sf::st_as_sf() %&gt;% sf::st_make_valid() sasquatch The Bigfoot Field Researchers Organization (BFRO) documents Bigfoot (Sasquatch) sightings; some data have been collated and packaged in stelfi assasquatch. data(&quot;sasquatch&quot;, package = &quot;stelfi&quot;) sasquatch ## Simple feature collection with 972 features and 27 fields ## Geometry type: POINT ## Dimension: XY ## Bounding box: xmin: -124.5301 ymin: 25.84875 xmax: -70.75587 ymax: 48.9058 ## CRS: +proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0 ## # A tibble: 972 × 28 ## observed locat…¹ county state season title date number class…² geohash ## * &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;date&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 &quot;For the… This l… Shann… Sout… Fall Repo… 2002-12-04 5173 Class A 9xxntv… ## 2 &quot;My fami… East o… Wayne… New … Fall Repo… 2003-09-20 26566 Class A dr9q4m… ## 3 &quot;While t… Ward C… Ward … Nort… Spring Repo… 2000-04-21 751 Class A c8xfw2… ## 4 &quot;(Please… &lt;NA&gt; Mount… Nort… Winter Repo… 2004-02-22 8165 Class A c8qzwb… ## 5 &quot;I was c… forest… Warre… New … Summer Repo… 2005-12-21 13276 Class B dr4xfu… ## 6 &quot;My summ… We wer… Taos … New … Spring Repo… 2000-05-17 4904 Class B 9wt01q… ## 7 &quot;On Aug … From G… McLea… Nort… Summer Repo… 2005-08-27 12562 Class A c8rx3m… ## 8 &quot;Foot pr… The lo… McKen… Nort… Winter Repo… 2004-02-26 8130 Class B c8qyyr… ## 9 &quot;The fol… Georgi… Sarpy… Nebr… Summer Repo… 2005-01-06 7809 Class A 9z7f40… ## 10 &quot;We live… (Locat… Dougl… Nebr… Summer Repo… 2005-08-13 12482 Class A 9z7f97… ## # … with 962 more rows, 18 more variables: temperature_high &lt;dbl&gt;, ## # temperature_mid &lt;dbl&gt;, temperature_low &lt;dbl&gt;, dew_point &lt;dbl&gt;, ## # humidity &lt;dbl&gt;, cloud_cover &lt;dbl&gt;, moon_phase &lt;dbl&gt;, ## # precip_intensity &lt;dbl&gt;, precip_probability &lt;dbl&gt;, precip_type &lt;chr&gt;, ## # pressure &lt;dbl&gt;, summary &lt;chr&gt;, uv_index &lt;dbl&gt;, visibility &lt;dbl&gt;, ## # wind_bearing &lt;dbl&gt;, wind_speed &lt;dbl&gt;, year &lt;dbl&gt;, geometry &lt;POINT [m]&gt;, and ## # abbreviated variable names ¹​location_details, ²​classification ggplot(sasquatch, aes(x = date)) + geom_histogram(bins = 150) + ylab(&quot;Frequency of Sasquatch sightings&quot;) + xlab(&quot;&quot;) + theme_bw() ggplot(sasquatch) + geom_sf(alpha = 0.3) + coord_sf() + geom_sf(data = us, fill = NA) + theme_classic() nz_earthquakes GeoNet Quake Search catalogues New Zealand earthquake occurrence; some of these data have been and packaged in stelfi as nz_earthquakes. In this chapter a Hawkes process is fitted to these data. data(&quot;nz_earthquakes&quot;, package = &quot;stelfi&quot;) nz_earthquakes ## Simple feature collection with 3824 features and 3 fields ## Geometry type: POINT ## Dimension: XY ## Bounding box: xmin: 169.83 ymin: -44.86892 xmax: 175.6328 ymax: -41.8628 ## CRS: +proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0 ## First 10 features: ## origintime magnitude depth geometry ## 1 2014-12-24 07:46:00 3.208996 13.671875 POINT (172.7133 -43.57944) ## 2 2014-12-24 06:43:00 4.109075 5.820312 POINT (172.7204 -43.55752) ## 3 2014-12-14 08:53:00 3.240377 5.058594 POINT (172.3641 -43.62563) ## 4 2014-12-12 13:37:00 4.459034 9.394531 POINT (172.368 -43.63492) ## 5 2014-11-20 08:24:00 3.116447 10.039062 POINT (172.7836 -43.42493) ## 6 2014-11-18 14:19:00 3.158710 11.269531 POINT (172.7936 -43.4897) ## 7 2014-11-02 06:45:00 3.708697 14.960938 POINT (170.2523 -44.48656) ## 8 2014-10-11 22:32:00 3.456145 39.804688 POINT (173.1383 -42.67562) ## 9 2014-10-01 20:58:00 3.106894 11.386719 POINT (172.6879 -43.49002) ## 10 2014-09-30 15:29:00 3.911931 9.335938 POINT (172.1428 -43.25048) ggplot(nz_earthquakes, aes(x = origintime)) + geom_histogram(bins = 100) + ylab(&quot;Frequency of earthquakes&quot;) + xlab(&quot;&quot;) + theme_bw() ggplot(nz_earthquakes) + geom_sf(alpha = 0.1) + coord_sf() + geom_sf(data = nz, fill = NA) + theme_classic() nz_murders The Homicide Report documents homicides in New Zealand. The nz_murders dataset contains summary information about the documented cases. In this chapter a spatiotemporal self-exciting model is fitted to these data. data(&quot;nz_murders&quot;, package = &quot;stelfi&quot;) nz_murders ## Simple feature collection with 967 features and 11 fields ## Geometry type: POINT ## Dimension: XY ## Bounding box: xmin: 167.9161 ymin: -46.96127 xmax: 178.3955 ymax: -34.54022 ## CRS: +proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0 ## First 10 features: ## sex age date year cause killer ## 1 Male 41 Jan 5 2004 stabbing friend ## 2 Male 46 Jan 8 2004 pick axe wounds friend ## 3 Male 0 Jan 15 2004 asphyxiation (suffocation) mother ## 4 Female 46 Feb 1 2004 blunt force trauma partner ## 5 Male 10 Feb 2 2004 stabbing father ## 6 Female 2 Feb 2 2004 stabbing father ## 7 Male 36 Feb 4 2004 stabbing partners ex-partner ## 8 Male 20 Feb 8 2004 car crash friend ## 9 Male 29 Feb 8 2004 blunt force trauma strangers ## 10 Female 32 Feb 15 2004 blunt force trauma husband ## name full_date month cause_cat region ## 1 Donald Linwood 2004-01-05 January Violent weapon Canterbury ## 2 James Weeks 2004-01-08 January Violent weapon Canterbury ## 3 Gabriel Harrison-Taylor 2004-01-15 January Asphyxia Auckland ## 4 Odette Lloyd-Rangiuia 2004-02-01 February Blunt force trauma Canterbury ## 5 Te Hau OCarroll 2004-02-02 February Violent weapon Wellington ## 6 Ngamata OCarroll 2004-02-02 February Violent weapon Wellington ## 7 Darryn McRobert 2004-02-04 February Violent weapon Canterbury ## 8 Peretiso Sauni 2004-02-08 February Car crash Auckland ## 9 Shannon McComb 2004-02-08 February Blunt force trauma Canterbury ## 10 Asolelei Sameulu 2004-02-15 February Blunt force trauma Auckland ## geometry ## 1 POINT (171.6442 -43.63394) ## 2 POINT (172.1305 -43.28563) ## 3 POINT (174.8498 -36.92575) ## 4 POINT (172.6327 -43.55006) ## 5 POINT (175.1195 -40.73297) ## 6 POINT (175.1193 -40.73273) ## 7 POINT (172.5172 -43.53866) ## 8 POINT (174.7335 -36.89708) ## 9 POINT (172.6429 -43.54363) ## 10 POINT (174.6274 -36.90353) ggplot(nz_murders, aes(x = full_date)) + geom_histogram(bins = 100) + ylab(&quot;Frequency of murders&quot;) + xlab(&quot;&quot;) + theme_bw() iraq_terrorism The Global Terrorism Database (GTD) documents information on terrorism events worldwide; some of these data have been and packaged in stelfi as iraq_terrorism. data(&quot;iraq_terrorism&quot;, package = &quot;stelfi&quot;) iraq_terrorism ## Simple feature collection with 4208 features and 16 fields ## Geometry type: POINT ## Dimension: XY ## Bounding box: xmin: 38.92288 ymin: 30.51005 xmax: 47.7781 ymax: 36.92948 ## CRS: +proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0 ## First 10 features: ## iyear imonth iday country success nkill specificity ## 18055 2013 4 18 Iraq TRUE 28 1 ## 18109 2013 4 20 Iraq TRUE 0 1 ## 18110 2013 4 20 Iraq TRUE 0 1 ## 18111 2013 4 20 Iraq TRUE 0 1 ## 18864 2013 5 16 Iraq TRUE 3 1 ## 18865 2013 5 16 Iraq TRUE 3 1 ## 18866 2013 5 16 Iraq TRUE 2 1 ## 18867 2013 5 16 Iraq TRUE 3 1 ## 19161 2013 5 27 Iraq TRUE 6 1 ## 19166 2013 5 27 Iraq TRUE 1 1 ## gname x_coord y_coord z_coord ## 18055 Islamic State of Iraq and the Levant (ISIL) 0.5974251 0.5844656 0.5490748 ## 18109 Islamic State of Iraq and the Levant (ISIL) 0.5997164 0.5864987 0.5443892 ## 18110 Islamic State of Iraq and the Levant (ISIL) 0.5992751 0.5859289 0.5454876 ## 18111 Islamic State of Iraq and the Levant (ISIL) 0.5959873 0.5733453 0.5622049 ## 18864 Islamic State of Iraq and the Levant (ISIL) 0.5974251 0.5844656 0.5490748 ## 18865 Islamic State of Iraq and the Levant (ISIL) 0.5974251 0.5844656 0.5490748 ## 18866 Islamic State of Iraq and the Levant (ISIL) 0.5974251 0.5844656 0.5490748 ## 18867 Islamic State of Iraq and the Levant (ISIL) 0.5876310 0.5507342 0.5927745 ## 19161 Islamic State of Iraq and the Levant (ISIL) 0.5974251 0.5844656 0.5490748 ## 19166 Islamic State of Iraq and the Levant (ISIL) 0.5974251 0.5844656 0.5490748 ## popdensity luminosity tt utm_x utm_y ## 18055 0.4065874 1.0924644 -0.3210921 333098.1 4007920.00 ## 18109 -0.3479151 0.2298066 -0.2726546 407264.8 5332968.87 ## 18110 -0.3479432 0.9717434 -0.3210921 401682.9 5252649.56 ## 18111 -0.3783331 1.0521158 -0.3210921 405272.2 5344797.97 ## 18864 0.4065874 1.0924644 -0.3210921 595450.3 4078540.46 ## 18865 0.4065874 1.0924644 -0.3210921 595450.3 4078540.46 ## 18866 0.4065874 1.0924644 -0.3210921 723492.7 45579.28 ## 18867 -0.3665068 1.0924644 -0.3210921 815931.5 435892.29 ## 19161 0.4065874 1.0924644 -0.3210921 252226.3 3703963.04 ## 19166 0.4065874 1.0924644 -0.3210921 756886.0 4023175.15 ## geometry ## 18055 POINT (44.37177 33.30357) ## 18109 POINT (44.3616 32.98293) ## 18110 POINT (44.35484 33.05799) ## 18111 POINT (43.89071 34.20842) ## 18864 POINT (44.37177 33.30357) ## 18865 POINT (44.37177 33.30357) ## 18866 POINT (44.37177 33.30357) ## 18867 POINT (43.14357 36.35415) ## 19161 POINT (44.37177 33.30357) ## 19166 POINT (44.37177 33.30357) iraq_terrorism %&gt;% mutate(date = paste(iday, imonth, iyear, sep = &quot;/&quot;)) %&gt;% mutate(date = as.Date(date, &quot;%d/%m/%Y&quot;)) %&gt;% ggplot(., aes(x = date)) + geom_histogram(bins = 150) + ylab(&quot;Frequency of attacks&quot;) + xlab(&quot;&quot;) + theme_bw() ggplot(iraq_terrorism) + geom_sf(alpha = 0.3) + coord_sf() + geom_sf(data = iraq, fill = NA) + theme_classic() 1.3 Simulated data xyt In this chapter a log-Gaussian Cox process is fitted to these data and in this chapter a spatiotemporal selfexciting model is fitted. data(&quot;xyt&quot;, package = &quot;stelfi&quot;) xyt_sf &lt;- sf::st_as_sf(xyt) xyt_sf ## Simple feature collection with 654 features and 1 field ## Geometry type: GEOMETRY ## Dimension: XY ## Bounding box: xmin: 0 ymin: -2.974928 xmax: 12.56637 ymax: 2.974928 ## CRS: NA ## First 10 features: ## label geom ## 1 window POLYGON ((10.77117 -2.78183... ## 2 point POINT (6.8074 -2.034423) ## 3 point POINT (7.558362 -2.193865) ## 4 point POINT (8.085083 -2.080938) ## 5 point POINT (8.121308 -2.522357) ## 6 point POINT (8.362448 -2.303117) ## 7 point POINT (9.000749 -2.955328) ## 8 point POINT (9.147803 -2.243146) ## 9 point POINT (9.261744 -2.408326) ## 10 point POINT (8.532312 -2.48986) ggplot(xyt_sf) + geom_sf(fill = NA) + theme_void() marked In this chapter a marked log-Gaussian Cox process is fitted to these data. data(marked, package = &quot;stelfi&quot;) marked_sf &lt;- sf::st_as_sf(x = marked, coords = c(&quot;x&quot;, &quot;y&quot;)) marked_sf ## Simple feature collection with 159 features and 3 fields ## Geometry type: POINT ## Dimension: XY ## Bounding box: xmin: 0.006606752 ymin: 0.006502493 xmax: 2.985087 ymax: 2.938558 ## CRS: NA ## First 10 features: ## m1 m2 m3 geometry ## 1 10.008609 0 9.616468 POINT (0.08935799 0.5756269) ## 2 8.730592 0 6.918024 POINT (2.177973 2.90455) ## 3 11.330677 0 16.798212 POINT (2.250791 1.024792) ## 4 11.338656 0 8.073566 POINT (2.033398 1.038773) ## 5 9.395725 0 9.977866 POINT (2.777002 0.4685442) ## 6 10.331965 0 10.615245 POINT (0.5988652 2.422233) ## 7 10.069787 0 11.268171 POINT (1.541071 0.9307671) ## 8 9.717775 0 13.306125 POINT (2.615062 1.064561) ## 9 10.071326 0 18.300715 POINT (0.3882139 2.146845) ## 10 10.147740 0 16.751740 POINT (1.501552 1.64466) domain &lt;- list(3 * cbind(c(0, 1, 1, 0, 0), c(0, 0, 1, 1, 0))) %&gt;% sf::st_polygon() %&gt;% sf::st_sfc() %&gt;% sf::st_sf(geometry = .) ggplot(marked_sf, aes(col = m1)) + geom_sf() + labs(color = &quot;Mark&quot;) + scale_color_continuous(type = &quot;viridis&quot;) + geom_sf(data = domain, fill = NA, inherit.aes = FALSE) + theme_void() horse_mesh In this chapter we illustrate different geometric metrics of this triangulation. data(&quot;horse_mesh&quot;, package = &quot;stelfi&quot;) horse_mesh_sf &lt;- stelfi::mesh_2_sf(horse_mesh) horse_mesh_sf ## Simple feature collection with 396 features and 4 fields ## Geometry type: POLYGON ## Dimension: XY ## Bounding box: xmin: -17.96875 ymin: -11.78261 xmax: 17.26563 ymax: 11.65217 ## CRS: NA ## First 10 features: ## V1 V2 V3 ID geometry ## 1 172 30 186 1 POLYGON ((8.441837 -2.16176... ## 2 28 188 162 2 POLYGON ((10.43359 0.913043... ## 3 168 186 42 3 POLYGON ((5.818232 -3.05894... ## 4 117 57 63 4 POLYGON ((-3.660156 -8.0326... ## 5 270 253 121 5 POLYGON ((-8.43636 2.023352... ## 6 92 144 169 6 POLYGON ((-8.042969 4.47826... ## 7 175 137 240 7 POLYGON ((5.689521 -1.13385... ## 8 182 148 111 8 POLYGON ((10.50244 7.199319... ## 9 253 169 121 9 POLYGON ((-7.850425 2.87106... ## 10 14 15 116 10 POLYGON ((13.3125 11.56522,... ggplot(horse_mesh_sf) + geom_sf(fill = NA, col = &quot;black&quot;) + theme_void() "],["key-stelfi-functions.html", "Chapter 2 Key stelfi functions", " Chapter 2 Key stelfi functions Summary of model fitting functions offered listing the key arguments for each. Function Key arguments fit_hawkes() times - a vector of numeric occurrence times. parameters - a vector of named starting values for \\(\\mu\\) (mu), \\(\\alpha\\) (alpha), and \\(\\beta\\) (beta). marks - optional, a vector of marks (\\(m(t)\\)). fit_hawkes_cbf() As fit_hawkes() plus background - some assumed time dependent background function \\(\\mu(t)\\). background_integral - the integral of background. background_parameters - parameter starting values for \\(\\mu(t)\\). ( \\(^*\\)Note, \\(\\texttt{mu}\\) in parameters will be ignored) fit_lgcp() locs - a named data frame of event locations, x, y, and t (optional). sf - a polygon of the spatial domain. smesh - a Delaunay triangulation of the spatial domain returned by INLA::inla.mesh.2d(). tmesh - optional, a temporal mesh returned by INLA::inla.mesh.1d()). parameters - a vector of named starting values for \\(\\boldsymbol{\\beta}\\) (beta), \\(\\text{log}(\\tau)\\) (log_tau), \\(\\text{log}(\\kappa)\\) (log_kappa), and \\(\\textrm{arctan}(\\rho)\\) (atanh_rho, optional). fit_mlgcp() locs, sf, and smesh - as fit_lgcp(). marks - a matrix of marks for each observation of the point pattern. parameters - a list of named parameters, as fit_lgcp() plus (betamarks), (betapp), (marks_coefs_pp ). methods - integer(s) specifying mark distribution: 0, Gaussian; 1, Poisson; 2, binomial; 3, gamma. strfixed - fixed structural parameters, depends on mark distribution. fields - a binary vector indicating whether there is a new random field for each mark. fit_stelfi() times - as fit_hawkes(). locs, sf, and smesh - as fit_lgcp(). parameters - a list of named parameter starting values for \\(\\mu\\) (mu), \\(\\alpha\\) (alpha), \\(\\beta\\) (beta), \\(\\sigma_x\\) (xsigma) \\(\\sigma_y\\) (ysigma), and \\(\\rho\\) (rho). GMRF - logical, should a GMRF be included as a latent spatial effect if so \\(\\tau\\) (tau) and \\(\\kappa\\)(kappa) supplied to parameters. Summary of utility and simulation functions listing the key arguments for each. Function Key arguments Purpose get_coefs() obj - a fitted model object returned by any one of the functions in the Table above Extract estimated parameter values from a fitted model. get_fields() As fit_lgcp() and sd - logical, return standard deviation. Extract estimated mean, or standard deviation, of GMRF(s). get_weights() mesh - a Delaunay triangulation of the spatial domain returned by INLA::inla.mesh. 2d(). sf - a polygon of the spatial domain. Calculate mesh weights. mesh_2_sf() mesh - a Delaunay triangulation of the spatial domain returned by INLA::inla.mesh. 2d(). Transforms mesh into a sf object. show_field() x - a vector of values, one per each smesh node. smesh - as fit_lgcp() . sf - as fit_lgcp(). clip - logical, clip to domain Plots spatial random field values. show_hawkes() obj - a fitted model object returned by fit_hawkes() or fit_hawkes_cbf(). Plot fitted Hawkes model. show_hawkes_GOF() obj - as show_hawkes(). plot - logical return_values - logical, return compensator values Plot goodness-of-fit metrics for a Hawkes model. show_lambda() As fit_lgcp() and clip - logical, clip to domain Plot estimated spatial intensity from a fitted log-Gaussian Cox process model. sim_hawkes() As fit_hawkes() Simulate a Hawkes process. sim_lgcp() As fit_lgcp() Simulate a realisation of a log-Gaussian Cox process. "],["hawkes.html", "Chapter 3 Hawkes process 3.1 The fit_hawkes() function 3.2 The fit_hawkes_cbf() function 3.3 The sim_hawkes() function", " Chapter 3 Hawkes process A univariate Hawkes process is defined to be a self-exciting temporal point process where the conditional intensity function is given by \\[\\lambda(t) = \\mu(t) + \\Sigma_{i:\\tau_i&lt;t}\\nu(t-\\tau_i)\\] where where \\(\\mu(t)\\) is the background rate of the process and \\(\\Sigma_{i:\\tau_i&lt;t}\\nu(t-\\tau_i)\\) is some historic temporal dependence. First introduced by Hawkes (1971), the classic homogeneous formulation is: \\[\\lambda(t) = \\mu + \\alpha \\Sigma_{i:\\tau_i&lt;t}\\text{exp}(-\\beta * (t-\\tau_i)) \\] 3.1 The fit_hawkes() function library(stelfi) args(fit_hawkes) ## function (times, parameters = list(), model = 1, marks = c(rep(1, ## length(times))), tmb_silent = TRUE, optim_silent = TRUE, ## ...) ## NULL 3.1.1 Fitting a Hawkes model A NIWA scientist found a working USB in the scat of a leopard seal, they then tweeted about it in the hopes of finding its owner. data(retweets_niwa) head(retweets_niwa) ## [1] &quot;2019-02-07 06:50:08 UTC&quot; &quot;2019-02-07 06:50:08 UTC&quot; ## [3] &quot;2019-02-07 06:49:22 UTC&quot; &quot;2019-02-07 06:48:48 UTC&quot; ## [5] &quot;2019-02-07 06:47:52 UTC&quot; &quot;2019-02-07 06:47:42 UTC&quot; ## numeric time stamps times &lt;- unique(sort(as.numeric(difftime(retweets_niwa ,min(retweets_niwa),units = &quot;mins&quot;)))) (#fig:plot hist)Observed counts of retweet times params &lt;- c(mu = 9, alpha = 3, beta = 10) fit &lt;- fit_hawkes(times = times, parameters = params) ## print out estimated parameters pars &lt;- get_coefs(fit) pars ## Estimate Std. Error ## mu 0.06328099 0.017783908 ## alpha 0.07596531 0.007777899 ## beta 0.07911346 0.008109789 show_hawkes(fit) show_hawkes_GOF(fit) ## ## Asymptotic one-sample Kolmogorov-Smirnov test ## ## data: interarrivals ## D = 0.031122, p-value = 0.0001937 ## alternative hypothesis: two-sided ## ## ## Box-Ljung test ## ## data: interarrivals ## X-squared = 3.3923, df = 1, p-value = 0.0655 3.1.2 Fitting an ETAS-type marked model Here we fit a univariate marked Hawkes process where the conditional intensity function is given by \\[\\lambda(t; m(t)) = \\mu + \\alpha \\Sigma_{i:\\tau_i&lt;t}m(\\tau_i)\\text{exp}(-\\beta * (t-\\tau_i)) \\] where \\(\\mu\\) is the background rate of the process and \\(m(t)\\) is the temporal mark. Each event \\(i\\) has an associated mark \\(\\tau_i\\) that multiples the self-exciting component of \\(\\lambda\\). In this example, the events are earthquakes and the marks are the Richter magnitude of each earthquake. data(&quot;nz_earthquakes&quot;) head(nz_earthquakes) ## Simple feature collection with 6 features and 3 fields ## Geometry type: POINT ## Dimension: XY ## Bounding box: xmin: 172.3641 ymin: -43.63492 xmax: 172.7936 ymax: -43.42493 ## CRS: +proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0 ## origintime magnitude depth geometry ## 1 2014-12-24 07:46:00 3.208996 13.671875 POINT (172.7133 -43.57944) ## 2 2014-12-24 06:43:00 4.109075 5.820312 POINT (172.7204 -43.55752) ## 3 2014-12-14 08:53:00 3.240377 5.058594 POINT (172.3641 -43.62563) ## 4 2014-12-12 13:37:00 4.459034 9.394531 POINT (172.368 -43.63492) ## 5 2014-11-20 08:24:00 3.116447 10.039062 POINT (172.7836 -43.42493) ## 6 2014-11-18 14:19:00 3.158710 11.269531 POINT (172.7936 -43.4897) nz_earthquakes &lt;- nz_earthquakes[order(nz_earthquakes$origintime),] nz_earthquakes &lt;- nz_earthquakes[!duplicated(nz_earthquakes$origintime),] times &lt;- nz_earthquakes$origintime times &lt;- as.numeric(difftime(times , min(times), units = &quot;mins&quot;)) marks &lt;- nz_earthquakes$magnitude params &lt;- c(mu = 3, alpha = 0.05, beta = 1) fit &lt;- fit_hawkes(times = times, parameters = params, marks = marks) ## print out estimated parameters pars &lt;- get_coefs(fit) pars ## Estimate Std. Error ## mu 0.0002001766 1.206014e-05 ## alpha 0.0005125373 2.934243e-05 ## beta 0.0020558328 1.204552e-04 show_hawkes(fit) show_hawkes_GOF(fit) ## ## Asymptotic one-sample Kolmogorov-Smirnov test ## ## data: interarrivals ## D = 0.035665, p-value = 0.0001912 ## alternative hypothesis: two-sided ## ## ## Box-Ljung test ## ## data: interarrivals ## X-squared = 104.09, df = 1, p-value &lt; 2.2e-16 3.2 The fit_hawkes_cbf() function args(fit_hawkes_cbf) ## function (times, parameters = list(), model = 1, marks = c(rep(1, ## length(times))), background, background_integral, background_parameters, ## background_min, tmb_silent = TRUE, optim_silent = TRUE) ## NULL 3.2.1 Fitting an inhomogenous Hawkes process Here we fit a univariate inhomogenous marked Hawkes process where the conditional intensity function is given by \\[\\lambda(t) = \\mu(t) + \\alpha \\Sigma_{i:\\tau_i&lt;t}\\text{exp}(-\\beta * (t-\\tau_i)) \\] The background \\(\\mu(t)\\) is time varying, rather than being constant. The following example uses simulated data. set.seed(1) library(hawkesbow) # Simulate a Hawkes process with mu = 1+sin(t), alpha=1, beta =2 times &lt;- hawkesbow::hawkes(1000, fun=function(y) {1+0.5*sin(y)}, M=1.5, repr=0.5, family=&quot;exp&quot;, rate=2)$p We will attempt to recover these parameter values, modelling the background as $ (t) = A + Bsin(t)$. The background will be written as a function of \\(x\\) and \\(y\\), where \\(A = e^x\\) and \\(B= logit(y) e^x\\). This formulation ensures the background is never negative. ## The background function must take a single parameter and the time(s) at which it is evaluated background &lt;- function(params,times){ A = exp(params[[1]]) B = stats::plogis(params[[2]]) * A return(A + B*sin(times)) } ## The background_integral function must take a single parameter and the time at which it is evaluated background_integral &lt;- function(params,x){ A = exp(params[[1]]) B = stats::plogis(params[[2]]) * A return((A*x)-B*cos(x)) } param = list(alpha = 0.5, beta = 1.5) background_param = list(1,1) fit &lt;- fit_hawkes_cbf(times = times, parameters = param, background = background, background_integral = background_integral, background_parameters = background_param) The estimated values of \\(A\\) and \\(B\\) respectively are exp(fit$background_parameters[1]) ## [1] 1.025526 plogis(fit$background_parameters[2]) * exp(fit$background_parameters[1]) ## [1] 0.5635566 The estimated values of \\(\\alpha\\) and \\(\\beta\\) respectively are: ab &lt;- get_coefs(fit)[1:2,1] ab ## alpha beta ## 1.040863 2.179564 3.3 The sim_hawkes() function args(sim_hawkes) ## function (mu, alpha, beta, n = 100, plot = FALSE, seed = 123, ## method = &quot;1&quot;) ## NULL method = 1 sim &lt;- sim_hawkes(mu = 2, alpha = 0.2, beta = 0.3, plot = TRUE) head(sim) ## [1] 0.6231314 0.7420664 0.7986166 2.0856174 2.1293941 2.4093639 method = 2 sim &lt;- sim_hawkes(mu = 2, alpha = 0.2, beta = 0.3, plot = TRUE, method = 2) head(sim) ## [1] 0.6231314 0.7314123 1.1083232 1.1571593 1.1795519 2.2830958 References "],["lgcp.html", "Chapter 4 Log-Gaussian Cox process 4.1 The fit_lgcp() function 4.2 The sim_lgcp() function", " Chapter 4 Log-Gaussian Cox process A Log-Gaussian Cox Process (LGCP) is a doubly stochastic spatial point process. In the simplest case, the intensity of the point process over space is given by: \\[\\Lambda(s) = \\text{exp}(\\beta_0 + G(s) + \\epsilon)\\] where \\(\\beta_0\\) is a constant, known as the intercept, \\(G(s)\\) is a Gaussian Markov Random Field (GMRF) and \\(\\epsilon\\) an error term. It is conventional to use Matérn covariance function to define the covariance of the random field. This takes two parameters \\(\\tau\\) and \\(\\kappa\\), commonly reported as \\(r=\\frac{\\sqrt{8}}{\\kappa}\\) and \\(\\sigma=\\frac{1}{\\sqrt{4\\pi\\kappa^2\\tau^2}}\\), where \\(r\\) is the range and \\(\\sigma\\) is the standard deviation. 4.1 The fit_lgcp() function args(fit_lgcp) ## function (locs, sf, smesh, tmesh, parameters, covariates, tmb_silent = TRUE, ## nlminb_silent = TRUE, ...) ## NULL 4.1.1 Fitting a spatial only LGCP data(xyt, package = &quot;stelfi&quot;) domain &lt;- sf::st_as_sf(xyt$window) locs &lt;- data.frame(x = xyt$x, y = xyt$y) bnd &lt;- INLA::inla.mesh.segment(as.matrix(sf::st_coordinates(domain)[, 1:2])) smesh &lt;- INLA::inla.mesh.2d(boundary = bnd, max.edge = 0.75, cutoff = 0.3) fit &lt;- fit_lgcp(locs = locs, sf = domain, smesh = smesh, parameters = c(beta = 0, log_tau = log(1), log_kappa = log(1))) get_coefs(fit) ## Estimate Std. Error ## beta 2.4481848 0.09034657 ## log_tau -1.3156570 0.33288053 ## log_kappa 0.9547072 0.29440167 ## range 1.0887319 0.32052449 ## stdev 0.4047190 0.05027126 get_fields(fit) |&gt; show_field(smesh = smesh, sf = domain) + ggplot2::theme_void() show_lambda(fit, smesh = smesh, sf = domain) + ggplot2::theme_void() 4.1.2 Spatiotemporal LGCP The LGCP model can also be used for spatiotemporal modelling where there is autoregressive temporal dependence. To achieve this, we choose an arbitrary number of time knots. The equation for an AR(1) process is as follows: \\[\\Lambda_i(s) = \\text{exp}(\\beta_0 + G_i(s) + \\epsilon)\\] where \\(i\\) indexes the time knot. \\(\\Lambda_i(s)\\) is the field intensity at time knot \\(i\\), and \\(G_i(s)\\) the GMRF at the same time knot. Each \\(G_i(s)\\) shares common values for \\(\\tau\\) and \\(\\kappa\\). Successive random fields are correlated through the formula \\[G_i(s)=\\rho G_{i-1}(s) + \\epsilon_i\\] where \\(\\rho\\) is a constant between -1 and +1, and \\(\\epsilon_i\\) is normally distributed with mean 0. ndays &lt;- 2 locs &lt;- data.frame(x = xyt$x, y = xyt$y, t = xyt$t) bnd &lt;- INLA::inla.mesh.segment(as.matrix(sf::st_coordinates(domain)[, 1:2])) w0 &lt;- 2 smesh &lt;- INLA::inla.mesh.2d(boundary = bnd, max.edge = 0.75, cutoff = 0.3) tmesh &lt;- INLA::inla.mesh.1d(seq(0, ndays, by = w0)) fit &lt;- fit_lgcp(locs = locs, sf = domain, smesh = smesh, tmesh = tmesh, parameters = c(beta = 0, log_tau = log(1), log_kappa = log(1), atanh_rho = 0.2)) get_coefs(fit) ## Estimate Std. Error ## rho 0.3100841 0.20738457 ## beta 1.6852264 0.13685037 ## log_tau -1.0683016 0.22402076 ## log_kappa 0.4785904 0.22707189 ## range 1.7526525 0.39797812 ## stdev 0.5087488 0.05765947 show_lambda(fit, smesh = smesh, sf = domain, tmesh = tmesh, timestamp = 1) + ggplot2::theme_void() + ggplot2::ggtitle(&quot;t = 1&quot;) show_lambda(fit, smesh = smesh, sf = domain, tmesh = tmesh, timestamp = 2) + ggplot2::theme_void() + ggplot2::ggtitle(&quot;t = 2&quot;) 4.2 The sim_lgcp() function Simulating a spatiotemporal LGCP Option 1 using sim_lgcp parameters &lt;- c(beta = 1, log_tau = log(1), log_kappa = log(1), atanh_rho = 0.2) simdata &lt;- sim_lgcp(parameters = parameters, sf = domain, smesh = smesh, tmesh = tmesh) simdata$x[,1] |&gt; show_field(smesh = smesh) + ggplot2::theme_void() Option 2 directly from the fitted model simdata &lt;- fit$simulate() simdata$x[,1] |&gt; show_field(smesh = smesh) + ggplot2::theme_void() "],["fit-marked.html", "Chapter 5 Marked log-Gaussian Cox process 5.1 The fit_mlgcp() function", " Chapter 5 Marked log-Gaussian Cox process Each event in a spatial LGCP may have a scalar or vector mark associated with it. In that case, we are interested not only in the spatial intensity of the point process but also the spatial distribution of the marks and the correlation between the marks and the point process. The intensity of the LGCP is as in the simple case: \\[\\Lambda_{pp}(s) = \\text{exp}(\\beta_{pp} + G_{pp}(s) + \\epsilon)\\] note the subscripts \\(pp\\) indicating the point process. The mark(s) have their own field: \\[\\Lambda_m(s)=\\beta_{m}+G_m(s)+\\alpha \\text{log}(\\Lambda_{pp}(s)) +\\epsilon\\] where \\(\\alpha\\) are coefficient(s) linking the point process and the mark(s). The meaning of \\(\\Lambda_m(s)\\) depends on the distribution of the marks. If the marks are from a Poisson distribution, it is the intensity (as with the point process). If the marks are from a Binomial distribution, it is the success probability, and the user must supply the number of trials for each event. If the marks are normally distributed, \\(\\Lambda_m(s)\\) models the mean, and the user must supply the standard deviation. The user can choose for the point processes and the marks to share a common GMRF, i.e. \\(G_m(s) = G_{pp}(s)\\) 5.1 The fit_mlgcp() function args(fit_mlgcp) ## function (locs, sf, marks, smesh, parameters = list(), methods, ## strfixed = matrix(1, nrow = nrow(locs), ncol = ncol(marks)), ## fields = rep(1, ncol(marks)), covariates, pp_covariates, ## marks_covariates, tmb_silent = TRUE, nlminb_silent = TRUE, ## ...) ## NULL 5.1.1 Fitting a marked LGCP data(marked, package = &quot;stelfi&quot;) loc.d &lt;- 3 * cbind(c(0, 1, 1, 0, 0), c(0, 0, 1, 1, 0)) domain &lt;- sf::st_sf(geometry = sf::st_sfc(sf::st_polygon(list(loc.d)))) smesh &lt;- INLA::inla.mesh.2d(loc.domain = loc.d, offset = c(0.3, 1), max.edge = c(0.3, 0.7), cutoff = 0.05) locs &lt;- cbind(x = marked$x, y = marked$y) marks &lt;- cbind(m1 = marked$m1) ## Gaussian parameters &lt;- list(betamarks = matrix(0, nrow = 1, ncol = ncol(marks)), log_tau = log(1), log_kappa = log(1), marks_coefs_pp = rep(0, ncol(marks)), betapp = 0) fit &lt;- fit_mlgcp(locs = locs, marks = marks, sf = domain, smesh = smesh, parameters = parameters, methods = 0, fields = 0) get_coefs(fit) ## Estimate Std. Error ## betamarks 9.9001308 0.3032841 ## betapp 2.7353453 0.1310755 ## marks_coefs_pp -0.2793250 0.4280345 ## tau 0.1028983 0.0594815 ## kappa 5.8998690 2.6928689 get_fields(fit, smesh) |&gt; show_field(smesh = smesh) + geom_sf(data = mesh_2_sf(smesh), fill = NA) + geom_sf(data = domain, fill = NA, col = &quot;black&quot;, lwd = 2) + geom_point(data = as.data.frame(locs), aes(x = x, y = y, cex = marks), alpha = 0.3, inherit.aes = FALSE) + theme_void() "],["stelfi.html", "Chapter 6 Spatiotemporal self-exciting models 6.1 The fit_stelfi() function", " Chapter 6 Spatiotemporal self-exciting models Although the Hawkes process is traditionally formulated as a temporal point process, it is also possible to formulate a spatiotemporal version of the Hawkes process. For the spatiotemporal Hawkes processes fitted by this package, temporal self-excitement follows an exponential decay function. The self-excitement over space follows a Gaussian distribution centered at the triggering event. There are two formulations of this model. The default is that the Gaussian function has a fixed covariance matrix, independent of time. Alternatively, covariance can be directly proportional to time, meaning that the self-excitement radiates out from the center over time. This can be appropriate when the mechanism causing self-excitement travels at a finite speed, but is very memory-intensive. The intensity function used by stelfi is \\[\\lambda(s,t) = \\mu + \\alpha \\Sigma_{i:\\tau_i&lt;t}(\\text{exp}(-\\beta * (t-\\tau_i)) G_i(s-x_i, t - \\tau_i)).\\] Here \\(\\mu\\) is the background rate, \\(\\beta\\) is the rate of temporal decay, \\(\\alpha\\) is the increase in intensity after an event, \\(\\tau_i\\) are the event times, \\(x_i\\) are the event locations (in 2D Euclidean space) and \\(G_i(s-x_i, t - \\tau_i)\\) is the spatial self-excitement kernel. For the version with time-independent spatial excitement: \\(G_i(s-x_i, t - \\tau_i) = f_X(s - x_i)\\) where \\(f_X\\) is the density function of \\(X \\sim \\text{N}(0, \\Sigma)\\) For the version with time-dependent spatial excitement: \\(G_i(s-x_i, t - \\tau_i) = f_X(s - x_i)\\) where \\(f_X\\) is the density function of \\(X \\sim \\text{N}(0, (t-\\tau_i)\\Sigma)\\) 6.1 The fit_stelfi() function args(fit_stelfi) ## function (times, locs, sf, smesh, parameters, covariates, GMRF = FALSE, ## time_independent = TRUE, tmb_silent = TRUE, nlminb_silent = TRUE, ## ...) ## NULL 6.1.1 Spatiotemporal Hawkes process data(xyt, package = &quot;stelfi&quot;) locs &lt;- data.frame(x = xyt$x, y = xyt$y) times &lt;- xyt$t domain &lt;- sf::st_as_sf(xyt$window) ggplot(data = locs, aes(x = x, y = y, size = times)) + geom_point() + geom_sf(data = domain, fill = NA, inherit.aes = FALSE) + theme_void() bnd &lt;- INLA::inla.mesh.segment(as.matrix(sf::st_coordinates(domain)[, 1:2])) smesh &lt;- INLA::inla.mesh.2d(boundary = bnd, max.edge = 0.75, cutoff = 0.3) param &lt;- list(mu = 1, alpha = 3, beta = 6, xsigma = 0.2, ysigma = 0.2, rho = 0) fit &lt;- fit_stelfi(times = times, locs = locs, sf = domain, smesh = smesh, parameters = param) get_coefs(fit) ## Estimate Std. Error ## mu 0.31682408 0.06432051 ## coefs -1.14940861 0.20301649 ## alpha 232.98697937 14.47443211 ## beta 232.98698056 14.47443202 ## xsigma 0.55456406 0.02336852 ## ysigma 0.28344566 0.01440343 ## rho 0.02843629 0.05804435 show_hawkes(list(times = times, params = c(mu = 0.32, alpha = 232, beta = 232))) 6.1.2 Including a random field ## Note: just because you can, doesn&#39;t mean you should... param &lt;- list(mu = 1, alpha = 20, beta = 200, kappa = 2, tau = 0.1, xsigma = 0.2, ysigma = 0.2, rho = 0) fit &lt;- fit_stelfi(times = times, locs = locs, sf = domain, smesh = smesh, parameters = param, GMRF = TRUE) get_coefs(fit) ## Estimate Std. Error ## mu 0.003432009 0.004005054 ## coefs -5.674609405 1.166970622 ## alpha 259.064098445 15.626830249 ## beta 259.064100335 15.626830029 ## xsigma 0.548451292 0.021614775 ## ysigma 0.296733579 0.014288649 ## rho 0.024276592 0.056616125 ## kappa 9.040965870 10.519143632 ## tau 0.004644277 0.009560608 show_hawkes(list(times = times, params = c(mu = 0.003, alpha = 259, beta = 259))) get_fields(fit, smesh) |&gt; show_field(smesh = smesh) + geom_sf(data = mesh_2_sf(smesh), fill = NA) + geom_sf(data = domain, fill = NA, col = &quot;black&quot;, lwd = 2) + theme_void() "],["meshmetrics.html", "Chapter 7 Delaunay triangulation metrics", " Chapter 7 Delaunay triangulation metrics data(&quot;horse_mesh&quot;, package = &quot;stelfi&quot;) metrics &lt;- meshmetrics(horse_mesh) str(metrics) ## Classes &#39;sf&#39; and &#39;data.frame&#39;: 396 obs. of 18 variables: ## $ V1 : int 172 28 168 117 270 92 175 182 253 14 ... ## $ V2 : int 30 188 186 57 253 144 137 148 169 15 ... ## $ V3 : int 186 162 42 63 121 169 240 111 121 116 ... ## $ ID : int 1 2 3 4 5 6 7 8 9 10 ... ## $ angleA : num 72.5 55.9 63.6 65.9 66.9 ... ## $ angleB : num 56.4 72.7 65.3 75.5 56.6 ... ## $ angleC : num 51.1 51.5 51.2 38.6 56.6 ... ## $ incircle_r : num 0.487 0.407 0.428 0.316 0.306 ... ## $ circumcircle_R: num 1.011 0.845 0.872 0.717 0.618 ... ## $ c_Ox : num 8.17 10.46 6.41 -3.77 -7.86 ... ## $ c_Oy : num -3.13 1.76 -3.7 -8.74 2.25 ... ## $ i_Ox : num 8.25 10.31 6.44 -3.57 -7.92 ... ## $ i_Oy : num -2.96 1.77 -3.58 -8.61 2.23 ... ## $ radius_edge : num 0.643 0.639 0.642 0.801 0.599 ... ## $ radius_ratio : num 0.482 0.482 0.491 0.44 0.495 ... ## $ area : num 1.264 0.883 0.963 0.568 0.488 ... ## $ quality : num 0.969 0.97 0.983 0.884 0.991 ... ## $ geometry :sfc_POLYGON of length 396; first list element: List of 1 ## ..$ : num [1:4, 1:2] 8.44 9.06 7.16 8.44 -2.16 ... ## ..- attr(*, &quot;class&quot;)= chr [1:3] &quot;XY&quot; &quot;POLYGON&quot; &quot;sfg&quot; ## - attr(*, &quot;sf_column&quot;)= chr &quot;geometry&quot; ## - attr(*, &quot;agr&quot;)= Factor w/ 3 levels &quot;constant&quot;,&quot;aggregate&quot;,..: NA NA NA NA NA NA NA NA NA NA ... ## ..- attr(*, &quot;names&quot;)= chr [1:17] &quot;V1&quot; &quot;V2&quot; &quot;V3&quot; &quot;ID&quot; ... Returned is an sf object with the following geometric attributes of the user supplied Delaunay triangulation V1, V2, and V3 corresponding vertices of mesh matches mesh$graph$tv; ID, numeric triangle id; angleA, angleB, and angleC, the interior angles; circumcircle radius, circumradius, circumcircle_R (); incircle radius incircle_r (\\(r\\)); centroid locations of the circumcircle, circumcenter, (c\\_Ox, c\\_Oy); centroid locations of the incircle, incenter, (i\\_Ox, i\\_Oy); the radius-edge ratio radius_edge \\(\\frac{R}{l_{min}}\\), where \\(l_{min}\\) is the minimum edge length; the radius ratio radius_ratio \\(\\frac{r}{R}\\); area, area (\\(A\\)); quality a measure of “quality” defined as \\(\\frac{4\\sqrt{3}|A|}{\\Sigma_{i = 1}^3 L_i^2}\\), where \\(L_i\\) is the length of edge \\(i\\). A triangle’s circumcircle (circumscribed circle) is the unique circle that passes through each of its three vertices. A triangle’s incircle (inscribed circle) is the largest circle that can be contained within it (i.e., touches it’s three edges). To plot each triangle’s metric of choice simply change the fill aesthetic. Simply a tool to identify “bad” triangles in the mesh. ggplot(metrics, aes(fill = area)) + geom_sf() + theme_void() ggplot(metrics, aes(fill = radius_edge)) + geom_sf() + theme_void() ggplot(metrics, aes(fill = quality)) + geom_sf() + theme_void() "],["references.html", "References", " References "]]
