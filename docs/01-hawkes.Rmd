# Hawkes process {#hawkes}

A  univariate Hawkes process is defined to be a self-exciting temporal point process where the conditional intensity function is given by

 $$\lambda(t) = \mu(t) + \Sigma_{i:\tau_i<t}\nu(t-\tau_i)$$ 
 where where $\mu(t)$ is the background rate of the process and $\Sigma_{i:\tau_i<t}\nu(t-\tau_i)$ is some historic temporal dependence. First introduced by @hawkes
 
 $$\lambda(t) = \mu(t) + \alpha \Sigma_{i:\tau_i<t}\text{exp}(-\beta * (t-\tau_i)) $$ 
 
## The `fit_hawkes()` function

```{r}
## devtools::load_all("~/Git/stelfi")
library(stelfi)
args(fit_hawkes)
```

**Retweets**

A [NIWA](https://niwa.co.nz/) scientist [found a working USB in the scat of a leopard seal](https://www.nzherald.co.nz/nz/news/article.cfm?c_id=1&objectid=12201147), they then [tweeted about it](https://twitter.com/niwa_nz/status/1092610541401587712) in the hopes of finding its owner.

```{r data,message=FALSE}
data(retweets_niwa)
head(retweets_niwa)
```

```{r sort data}
## numeric time stamps
times <- unique(sort(as.numeric(difftime(retweets_niwa ,min(retweets_niwa),units = "mins"))))
```


```{r plot hist, echo = FALSE, fig.cap = "Observed counts of retweet times.",fig.height = 5,fig.width = 8}
# NIWA seal first tweet according to Twitter
start <- lubridate::ymd_hms("2019-02-05 02:27:07")
## NIWA seal found owner tweet according to Twitter
end <- lubridate::ymd_hms("2019-02-07 06:50:08")
## hist
hist(retweets_niwa, breaks = "hours", axes = FALSE, 
     xlab = "", ylab = "",main = "", col = "grey",border = "grey",freq = TRUE)
axis(2,at = c(0,250))
mtext(2, line = 0, text = "Number of retweets per hour",cex = 0.8)
mtext(1,line = 1, at = c(start,end),text = c("NIWA \n tweeted","USB owner \n found"),cex = 0.9)
```



```{r fit model,results = 'hide',cache = TRUE}
params <- c(mu = 9, alpha = 3, beta = 10)
## must have compiled TMB templates first use compile_stelfi()
fit <- fit_hawkes(times = times,parameters = params) 
```


```{r params}
## print out estimated parameters
pars <- get_coefs(fit)
pars
```



```{r plot, echo = TRUE,fig.height = 7,fig.width = 9}
show_hawkes(times = times, mu = pars[1,1], alpha = pars[2,1], beta = pars[3,1])
```


```{r gof, echo = TRUE,fig.height = 7,fig.width = 9}
show_hawkes_GOF(times = times, mu = pars[1,1], alpha = pars[2,1], beta = pars[3,1], return_values = FALSE)
```

**ETAS marked model**

Here we fit a univariate marked Hawkes process  where the conditional intensity function is given by

 $$\lambda(t; m(t)) = \mu(t) + \alpha \Sigma_{i:\tau_i<t}m(t-\tau_i)\text{exp}(-\beta * (t-\tau_i)) $$ 
where $\mu(t)$ is the background rate of the process, $m(t)$ is the temporal mark and $\Sigma_{i:\tau_i<t}\nu(t-\tau_i)$ is some historic temporal dependence.

```{r}
data("earthquakes")
head(earthquakes)
earthquakes <- earthquakes[order(earthquakes$origintime),]
earthquakes <- earthquakes[!duplicated(earthquakes$origintime),]
times <- earthquakes$origintime
times <- as.numeric(difftime(times , min(times), units = "mins"))
marks <- earthquakes$magnitude
params <- c(mu = 3, alpha = 0.05, beta = 1)
## must have compiled TMB templates first use compile_stelfi()
fit <- fit_hawkes(times = times, parameters = params, marks = marks) 
## print out estimated parameters
pars <- get_coefs(fit)
pars
```

```{r, echo = TRUE,fig.height = 7,fig.width = 9}
show_hawkes(times = times, mu = pars[1,1], alpha = pars[2,1], beta = pars[3,1], marks = marks)
```


```{r, echo = TRUE,fig.height = 7,fig.width = 9}
show_hawkes_GOF(times = times, mu = pars[1,1], alpha = pars[2,1], beta = pars[3,1], marks = marks, return_values = FALSE)
```



## The `fit_hawkes_cbf()` function

The previous two examples were homogenous; \mu(t) was constant. Inhomogenous Hawke's procceses are those with a non-constant background function \mu(t). In this example we used simulated data



```{r}
args(fit_hawkes_cbf)
set.seed(1)
library(hawkesbow)
# Simulate a Hawkes process with mu = 1+sin(t), alpha=1, beta =2
times <- hawkesbow::hawkes(1000, fun=function(y) {1+0.5*sin(y)}, M=1.5, repr=0.5, family="exp", rate=2)$p
```

We will attempt to recover these parameter values, modelling the background as $ \mu(t) = A + Bsin(t)$. The background will be written as a function of $x$ and $y$, where $A = e^x$ and $B= logit(y) e^x$. This formulation ensures the background is never negative. 

```{r}
## The background function must take a single parameter and the time(s) at which it is evaluated
background <- function(params,times){
        A = exp(params[[1]])
        B = stats::plogis(params[[2]]) * A
        return(A + B*sin(times))
}

## The background_integral function must take a single parameter and the time at which it is evaluated
background_integral <- function(params,x){
        A = exp(params[[1]])
        B = stats::plogis(params[[2]]) * A
        return((A*x)-B*cos(x))
}
param = list(alpha = 0.5, beta = 1.5)
background_param = list(1,1)
fit <- fit_hawkes_cbf(times = times, parameters = param, background = background, background_integral = background_integral, background_parameters = background_param)
```

The estimated values of $A$ and $B$ respectively are 
```{r}
exp(fit$background_parameters[1])
plogis(fit$background_parameters[2]) * exp(fit$background_parameters[1])
```

The estimated values of $\alpha$ and $\beta$ respectively are:
```{r}
fit$alpha
fit$beta
```

```{r, echo = TRUE,fig.height = 7,fig.width = 9}
show_hawkes(times = times, mu = background, alpha = fit$alpha, beta = fit$beta, background_param = fit$background_parameters)
```
```{r, echo = TRUE,fig.height = 7,fig.width = 9}
show_hawkes_GOF(times = times, mu = background_integral, alpha = fit$alpha, beta = fit$beta, background_param = fit$background_parameters, return_values = FALSE)
```