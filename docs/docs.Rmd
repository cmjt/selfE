--- 
title: "Fitting models using `stelfi`"
author: "Charlotte M. Jones-Todd & Alec van Helsdingen"
date: ""
site: bookdown::bookdown_site
documentclass: book
bibliography: [book.bib, packages.bib]
biblio-style: apalike
link-citations: yes
description: "Using `stelfi`"
---

##### Charlotte M. Jones-Todd & Alec van Helsdingen


# Installation {-}

The `stelfi` package can be installed from Github:

```{r eval=FALSE}
devtools::install_github("cmjt/stelfi")
```

**Compiling templates**

Before using the  `TMB` templates in `stelfi` you should use `compile_stelfi()` to compile them:

```{r library,results = 'hide',message = FALSE, echo = FALSE}
library(stelfi)
```

```{r compile, eval = FALSE}
stelfi::compile_stelfi()
```


```{r include = FALSE}
# automatically create a bib database for R packages
knitr::write_bib(c(
  .packages(), 'bookdown', 'knitr', 'rmarkdown'
), 'packages.bib')
knitr::opts_chunk$set(cache = TRUE, message = FALSE, warning = FALSE)
```

<!--chapter:end:index.Rmd-->

# Datasets in `stelfi` {#data}

Below are the data packaged within `stelfi`; later chapters use the functionality offered by `stelfi` to model these data.

```{r}
library(stelfi)
data(package = "stelfi")$result[, c("Item", "Title")]
```


## Temporal point pattern data



```{r, message=FALSE}
## load the tidyverse packages
library(tidyverse)
```

### `retweets_niwa`  {-}

In 2019 a [NIWA](https://niwa.co.nz/) scientist [found a working USB in the scat of a leopard seal](https://www.nzherald.co.nz/nz/news/article.cfm?c_id=1&objectid=12201147), they then [tweeted about it](https://twitter.com/niwa_nz/status/1092610541401587712) in the hopes of finding its owner.

```{r, echo = FALSE}
##devtools::install_github("gadenbuie/tweetrmd")
library(tweetrmd)
include_tweet("https://twitter.com/niwa_nz/status/1092610541401587712")
```

The `retweets_niwa` dataset contains the retweet timestamps for this tweet.

```{r}
data(retweets_niwa, package = "stelfi")
head(retweets_niwa)
```

```{r}
ggplot(data.frame(time = retweets_niwa), aes(x = time)) + 
  geom_histogram() + ylab("Retweet frequency") + xlab("") +
  theme_bw()

```


### `serial_uk`  {-}

[Murder UK](http://www.murderuk.com/) documents some of the UKs most infamous multiple murderer cases. The `serial_uk` dataset contains summary information about the documented cases along with approximate timeframes.

```{r}
data("serial_uk", package = "stelfi")
head(serial_uk)
```


```{r}
serial_uk %>%
  mutate(time =  paste(Date.of.first.kill, "/01", sep='')) %>%
  mutate(time = as.Date(time, "%m/%Y/%d")) %>%
  ggplot(aes(x = time)) + 
  geom_histogram() + 
  ylab("Frequency of known first kill") + 
  xlab("") + theme_bw()

```



## Spatiotemporal point pattern data

Using `maps` to create `sf` objects of country boundaries:

```{r}
us <- maps::map("usa", fill = TRUE, plot = FALSE) %>%
    sf::st_as_sf() %>%
    sf::st_make_valid()
nz <- maps::map("nz", fill = TRUE, plot = FALSE) %>%
    sf::st_as_sf() %>%
    sf::st_make_valid()
iraq <- maps::map("world", "Iraq", fill = TRUE, plot = FALSE) %>%
     sf::st_as_sf() %>%
    sf::st_make_valid()
```

### `bigfoot`  {-}

The [Bigfoot Field Researchers Organization (BFRO)](https://www.bfro.net/) documents Bigfoot (Sasquatch) sightings; some data have been [collated](https://data.world/timothyrenner/bfro-sightings-data) and packaged in `stelfi` as`bigfoot`.

```{r}
data("bigfoot", package = "stelfi")
bigfoot
```

```{r}
ggplot(bigfoot, aes(x = date)) + geom_histogram(bins = 150) +
  ylab("Frequency of Sasquatch sightings") + xlab("") +
  theme_bw()
```

```{r}
ggplot(bigfoot) +  
  geom_sf(alpha = 0.3) + 
  coord_sf() + 
  geom_sf(data = us, fill = NA) + 
  theme_classic()
```

### `ufo`  {-}


The [UFO Sightings Map](https://www.arcgis.com/apps/webappviewer/index.html?id=ddda71d5211f47e782b12f3f8d06246e) shows reports of UFO sightings in the United States; some data have been [collated](https://data.world/timothyrenner/ufo-sightings#) and packaged in `stelfi` as `ufo`.

```{r}
data("ufo", package = "stelfi")
ufo
```

```{r}
ggplot(ufo, aes(x = date_time)) + geom_histogram(bins = 150) +
  ylab("Frequency of UFO sightings") + xlab("") +
  theme_bw()
```

```{r}
ggplot(ufo) +  
  geom_sf(alpha = 0.1, size = 1) + 
  coord_sf() + 
  geom_sf(data = us, fill = NA) +
  theme_classic()
```

### `earthquakes`  {-}

[GeoNet Quake Search](http://quakesearch.geonet.org.nz/) catalogues New Zealand earthquake occurrence; some of these data have been and packaged in `stelfi` as `earthquakes`.

```{r}
data("earthquakes", package = "stelfi")
earthquakes
```

```{r}
ggplot(earthquakes, aes(x = origintime)) + geom_histogram(bins = 100) +
  ylab("Frequency of earthquakes") + xlab("") +
  theme_bw()
```

```{r}
ggplot(earthquakes) +  
  geom_sf(alpha = 0.1) + 
  coord_sf() + 
  geom_sf(data = nz, fill = NA) +
  theme_classic()
```

### `murders_nz`  {-}

[The Homicide Report](https://interactives.stuff.co.nz/2019/the-homicide-report/) documents homicides in New Zealand. The `murders_nz` dataset contains summary information about the documented cases.

```{r}
data("murders_nz", package = "stelfi")
murders_nz
```

```{r}
ggplot(murders_nz, aes(x = Full_date)) + geom_histogram(bins = 100) +
  ylab("Frequency of murders") + xlab("") +
  theme_bw()
```

```{r}
ggplot(murders_nz) +  
  geom_sf(alpha = 0.5) + 
  coord_sf() + 
  geom_sf(data = nz, fill = NA) +
  theme_classic()
```

### `terrorism`  {-}

[The Global Terrorism Database (GTD)](http://www.start.umd.edu/gtd/) documents information on terrorism events worldwide; some of these data have been and packaged in `stelfi` as `terrorism`.


```{r}
data("terrorism", package = "stelfi")
terrorism
```


```{r}
terrorism %>%
  mutate(date = paste(iday, imonth, iyear, sep = "/")) %>%
  mutate(date = as.Date(date, "%d/%m/%Y")) %>%
  ggplot(., aes(x = date)) + geom_histogram(bins = 150) +
  ylab("Frequency of attacks") + xlab("") +
  theme_bw()
```

```{r}
ggplot(terrorism) +  
  geom_sf(alpha = 0.3) + 
  coord_sf() + 
  geom_sf(data = iraq, fill = NA) +
  theme_classic()
```

## Simulated data

### `xyt`  {-}

```{r}
data("xyt", package = "stelfi")
xyt_sf <- sf::st_as_sf(xyt)
xyt_sf
```

```{r}
ggplot(xyt_sf) + geom_sf(fill = NA) +
  theme_void()
```


### `marked`  {-}

```{r}
data(marked, package = "stelfi")
marked_sf <- sf::st_as_sf(x = marked,
                        coords = c("x", "y"))
marked_sf
```

```{r}
domain <- list(3 * cbind(c(0, 1, 1, 0, 0), c(0, 0, 1, 1, 0))) %>%
  sf::st_polygon() %>% sf::st_sfc() %>% sf::st_sf(geometry = .)

ggplot(marked_sf, aes(col = m1)) + 
  geom_sf() + labs(color = "Mark") +
  scale_color_continuous(type = "viridis") +
  geom_sf(data = domain, fill = NA, inherit.aes = FALSE) +
  theme_void()
```


### `horse_mesh` {-}

```{r}
data("horse_mesh", package = "stelfi")
horse_mesh_sf <- stelfi::mesh_2_sf(horse_mesh)
horse_mesh_sf
```

```{r}
ggplot(horse_mesh_sf) + geom_sf(fill = NA, col = "black") +
  theme_void()
```

<!--chapter:end:00-data.Rmd-->

# Hawkes process {#hawkes}

A  univariate Hawkes process is defined to be a self-exciting temporal point process where the conditional intensity function is given by

 $$\lambda(t) = \mu(t) + \Sigma_{i:\tau_i<t}\nu(t-\tau_i)$$ 
 where where $\mu(t)$ is the background rate of the process and $\Sigma_{i:\tau_i<t}\nu(t-\tau_i)$ is some historic temporal dependence. First introduced by @hawkes, the classic homogeneous formulation is:
 
 $$\lambda(t) = \mu + \alpha \Sigma_{i:\tau_i<t}\text{exp}(-\beta * (t-\tau_i)) $$ 
 
## The `fit_hawkes()` function

```{r}
args(fit_hawkes)
```

### Fitting a Hawkes model

A [NIWA](https://niwa.co.nz/) scientist [found a working USB in the scat of a leopard seal](https://www.nzherald.co.nz/nz/news/article.cfm?c_id=1&objectid=12201147), they then [tweeted about it](https://twitter.com/niwa_nz/status/1092610541401587712) in the hopes of finding its owner.

```{r data,message=FALSE}
data(retweets_niwa)
head(retweets_niwa)
```

```{r sort data}
## numeric time stamps
times <- unique(sort(as.numeric(difftime(retweets_niwa ,min(retweets_niwa),units = "mins"))))
```


```{r plot hist, echo = FALSE, fig.cap = "Observed counts of retweet times", fig.height = 5,fig.width = 8}
# NIWA seal first tweet according to Twitter
start <- lubridate::ymd_hms("2019-02-05 02:27:07")
## NIWA seal found owner tweet according to Twitter
end <- lubridate::ymd_hms("2019-02-07 06:50:08")
## hist
hist(retweets_niwa, breaks = "hours", axes = FALSE, 
     xlab = "", ylab = "",main = "", col = "grey",border = "grey",freq = TRUE)
axis(2,at = c(0,250))
mtext(2, line = 0, text = "Number of retweets per hour",cex = 0.8)
mtext(1,line = 1, at = c(start,end),text = c("NIWA \n tweeted","USB owner \n found"),cex = 0.9)
```



```{r fit model,results = 'hide',cache = TRUE}
params <- c(mu = 9, alpha = 3, beta = 10)
## must have compiled TMB templates first use compile_stelfi()
fit <- fit_hawkes(times = times, parameters = params) 
```


```{r params}
## print out estimated parameters
pars <- get_coefs(fit)
pars
```



```{r plot, echo = TRUE,fig.height = 7,fig.width = 9}
show_hawkes(fit)
```


```{r gof, echo = TRUE,fig.height = 7,fig.width = 9}
show_hawkes_GOF(fit)
```

### Fitting an ETAS-type marked model

Here we fit a univariate marked Hawkes process  where the conditional intensity function is given by

 $$\lambda(t; m(t)) = \mu + \alpha \Sigma_{i:\tau_i<t}m(\tau_i)\text{exp}(-\beta * (t-\tau_i)) $$ 
where $\mu$ is the background rate of the process and $m(t)$ is the temporal mark. Each event $i$ has an associated mark $\tau_i$ that multiples the self-exciting component of $\lambda$. 

In this example, the events are earthquakes and the marks are the Richter magnitude of each earthquake. 

```{r}
data("earthquakes")
head(earthquakes)
earthquakes <- earthquakes[order(earthquakes$origintime),]
earthquakes <- earthquakes[!duplicated(earthquakes$origintime),]
times <- earthquakes$origintime
times <- as.numeric(difftime(times , min(times), units = "mins"))
marks <- earthquakes$magnitude
params <- c(mu = 3, alpha = 0.05, beta = 1)
## must have compiled TMB templates first use compile_stelfi()
fit <- fit_hawkes(times = times, parameters = params, marks = marks) 
## print out estimated parameters
pars <- get_coefs(fit)
pars
```

```{r, echo = TRUE,fig.height = 7,fig.width = 9}
show_hawkes(fit)
```


```{r, echo = TRUE,fig.height = 7,fig.width = 9}
show_hawkes_GOF(fit)
```



## The `fit_hawkes_cbf()` function

```{r}
args(fit_hawkes_cbf)
```


### Fitting an inhomogenous Hawkes process

Here we fit a univariate *inhomogenous* marked Hawkes process where the conditional intensity function is given by

 $$\lambda(t) = \mu(t) + \alpha \Sigma_{i:\tau_i<t}\text{exp}(-\beta * (t-\tau_i)) $$ 
The background $\mu(t)$ is time varying, rather than being constant. 

The following example uses simulated data. 

```{r}
set.seed(1)
library(hawkesbow)
# Simulate a Hawkes process with mu = 1+sin(t), alpha=1, beta =2
times <- hawkesbow::hawkes(1000, fun=function(y) {1+0.5*sin(y)}, M=1.5, repr=0.5, family="exp", rate=2)$p
```

We will attempt to recover these parameter values, modelling the background as $ \mu(t) = A + Bsin(t)$. The background will be written as a function of $x$ and $y$, where $A = e^x$ and $B= logit(y) e^x$. This formulation ensures the background is never negative. 

```{r}
## The background function must take a single parameter and the time(s) at which it is evaluated
background <- function(params,times){
        A = exp(params[[1]])
        B = stats::plogis(params[[2]]) * A
        return(A + B*sin(times))
}

## The background_integral function must take a single parameter and the time at which it is evaluated
background_integral <- function(params,x){
        A = exp(params[[1]])
        B = stats::plogis(params[[2]]) * A
        return((A*x)-B*cos(x))
}
param = list(alpha = 0.5, beta = 1.5)
background_param = list(1,1)
fit <- fit_hawkes_cbf(times = times, parameters = param, background = background, background_integral = background_integral, background_parameters = background_param)
```

The estimated values of $A$ and $B$ respectively are 

```{r}
exp(fit$background_parameters[1])
plogis(fit$background_parameters[2]) * exp(fit$background_parameters[1])
```

The estimated values of $\alpha$ and $\beta$ respectively are:

```{r}
ab = get_coefs(fit)[1:2,1]
ab
```

<!--chapter:end:01-hawkes.Rmd-->

# A log-Gaussian Cox Process {#lgcp}

A Log-Gaussian Cox Process (LGCP) is a doubly stochastic spatial point process. In the simplest case, the intensity of the point process over space is given by:
$$\Lambda(s) = \text{exp}(\beta_0 + G(s) + \epsilon)$$
where $\beta_0$ is a constant, known as the intercept, $G(s)$ is a Gaussian Markov Random Field (GMRF) and $\epsilon$ an error term. 

It is conventional to use Matérn covariance function to define the covariance of the random field. This takes two parameters $\tau$ and $\kappa$, commonly reported as $r=\frac{\sqrt{8}}{\kappa}$ and $\sigma=\frac{1}{\sqrt{4\pi\kappa^2\tau^2}}$, where $r$ is the range and $\sigma$ is the standard deviation. 

## The `fit_lgcp()` function

```{r}
args(fit_lgcp)
```


### Fitting a spatial only LGCP

```{r}
data(xyt, package = "stelfi")
domain <- sf::st_as_sf(xyt$window)
locs <- data.frame(x = xyt$x, y = xyt$y)
bnd <- INLA::inla.mesh.segment(as.matrix(sf::st_coordinates(domain)[, 1:2]))
smesh <- INLA::inla.mesh.2d(boundary = bnd,
                                max.edge = 0.75, cutoff = 0.3)
fit <- fit_lgcp(locs = locs, sf = domain, smesh = smesh,
                                parameters = c(beta = 0, log_tau = log(1),
                                               log_kappa = log(1)))
get_coefs(fit)
```


```{r}
show_lambda(fit, smesh = smesh) + theme_void()
```


### Spatiotemporal LGCP

The LGCP model can also be used for spatiotemporal modelling where there is autoregressive temporal dependence. 

To achieve this, we choose an arbitrary number of time knots. The equation for an AR(1) process is as follows:
$$\Lambda_i(s) = \text{exp}(\beta_0 + G_i(s) + \epsilon)$$
where $i$ indexes the time knot. $\Lambda_i(s)$ is the field intensity at time knot $i$, and $G_i(s)$ the GMRF at the same time knot. Each $G_i(s)$ shares common values for $\tau$ and $\kappa$. 

Successive random fields are correlated through the formula
$$G_i(s)=\rho G_{i-1}(s) + \epsilon_i$$
where $\rho$ is a constant between -1 and +1, and $\epsilon_i$ is normally distributed with mean 0. 

```{r}
 ndays <- 2
locs <- data.frame(x = xyt$x, y = xyt$y, t = xyt$t)
bnd <- INLA::inla.mesh.segment(as.matrix(sf::st_coordinates(domain)[, 1:2]))
w0 <- 2
smesh <- INLA::inla.mesh.2d(boundary = bnd,
                                max.edge = 0.75, cutoff = 0.3)
tmesh <- INLA::inla.mesh.1d(seq(0, ndays, by = w0))
fit <- fit_lgcp(locs = locs, sf = domain, smesh = smesh, tmesh = tmesh,
                    parameters = c(beta = 0, log_tau = log(1),
                                   log_kappa = log(1), atanh_rho = 0.2))
get_coefs(fit)
```


```{r}

show_lambda(fit, smesh = smesh, tmesh = tmesh, timestamp = 1) +
    ggplot2::theme_void() + ggplot2::ggtitle("t = 2")
show_lambda(fit, smesh = smesh, tmesh = tmesh, timestamp = 2) +
    ggplot2::theme_void() + ggplot2::ggtitle("t = 2")

```

### Simulating a spatiotemporal LGCP

**Option 1** using `simulate_lgcp`

```{r}
parameters <- c(beta = 1, log_tau = log(1), log_kappa = log(1), atanh_rho = 0.2)
simdata <- simulate_lgcp(parameters = parameters, sp = domain, smesh = smesh, tmesh = tmesh)
show_field(simdata$x[,1], smesh = smesh) +
    ggplot2::theme_void()
```

**Option 2** directly from the fitted model

```{r}
simdata <- fit$simulate(fit$env$last.par, complete = FALSE)
show_field(simdata$x[,1], smesh = smesh) +
    ggplot2::theme_void()
```


<!--chapter:end:02-lgcp.Rmd-->

# A marked log-Gaussian Cox Process {#marked}

Each event in a spatial LGCP may have a scalar or vector mark associated with it. In that case, we are interested not only in the spatial intensity of the point process but also the spatial distribution of the marks and the correlation between the marks and the point process. 

The intensity of the LGCP is as in the simple case:
$$\Lambda_{pp}(s) = \text{exp}(\beta_{pp} + G_{pp}(s) + \epsilon)$$
note the subscripts $pp$ indicating the point process. 

The mark(s) have their own field:
$$\Lambda_m(s)=\beta_{m}+G_m(s)+\alpha   \text{log}(\Lambda_{pp}(s)) +\epsilon$$
where $\alpha$ are coefficient(s) linking the point process and the mark(s). 
The meaning of $\Lambda_m(s)$ depends on the distribution of the marks. If the marks are from a Poisson distribution, it is the intensity (as with the point process). If the marks are from a Binomial distribution, it is the success probability, and the user must supply the number of trials for each event. If the marks are normally distributed, $\Lambda_m(s)$ models the mean, and the user must supply the standard deviation.
The user can choose for the point processes and the marks to share a common GMRF, i.e. $G_m(s) = G_{pp}(s)$


## The `fit_mlgcp()` function

```{r}
args(fit_mlgcp)
```

### Fitting a marked LGCP

```{r, eval = TRUE}
data(marked, package = "stelfi")
loc.d <- 3 * cbind(c(0, 1, 1, 0, 0), c(0, 0, 1, 1, 0))
domain <- sp::SpatialPolygons(list(sp::Polygons(list(sp::Polygon(loc.d)),'0')))
smesh <- INLA::inla.mesh.2d(loc.domain = loc.d, offset = c(0.3, 1), 
                           max.edge = c(0.3, 0.7), cutoff = 0.05)
locs <- cbind(x = marked$x, y = marked$y)
marks <- cbind(m1 = marked$m1) ## Gaussian
parameters <- list(betamarks = matrix(0, nrow = 1, ncol = ncol(marks)) ,
              log_tau = log(1), log_kappa = log(1),
              marks_coefs_pp = rep(0, ncol(marks)), betapp = 0)

fit <- fit_mlgcp(locs = locs, marks = marks,
                 sp = domain, smesh = smesh,
                 parameters = parameters, methods = 0,
                 fields = 0)
get_coefs(fit)
```

<!--chapter:end:03-marked.Rmd-->

# Spatiotemporal self-exciting model {#stelfi}

## The `fit_stelfi()` function

```{r}
args(fit_stelfi)
```

## Hawkes spatial

```{r}
data(xyt, package = "stelfi")
N <- 50
locs <- data.frame(x = xyt$x[1:N], y = xyt$y[1:N])
times <- xyt$t[1:N]
loc.d <- cbind(c(0, 13, 13, 0, 0), c(-3, -3, 3, 3, -3))
domain <- sp::SpatialPolygons(list(sp::Polygons(list(sp::Polygon(loc.d)),'0')))
smesh <- INLA::inla.mesh.2d(boundary = INLA::inla.sp2segment(domain), 
                            max.edge = 0.75, cutoff = 0.3)
param <- list( mu = 3, alpha = 1, beta = 3, xsigma = 0.2,
             ysigma = 0.2, rho = 0.8)
fit <- fit_stelfi(times = times, locs = locs, sp = domain, smesh = smesh, parameters = param,
                  gaussian = TRUE)
get_coefs(fit)
```


## Hawkes spde

```{r}

## issues with time....
param <- list( mu = 5, alpha = 1, beta = 3, kappa = 0.9, tau = 1,
              xsigma = 0.2,
              ysigma = 0.2, rho = 0.8)
fit <- fit_stelfi(times = times, locs = locs, sp = domain,
                  smesh = smesh, parameters = param,
                  gaussian = FALSE)
get_coefs(fit)
```

<!--chapter:end:04-stelfi.Rmd-->


<!--chapter:end:05-meshmetrics.Rmd-->

`r if (knitr::is_html_output()) '
# References {-}
'`

<!--chapter:end:06-references.Rmd-->

