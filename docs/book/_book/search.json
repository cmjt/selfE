[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "The R package stelfi",
    "section": "",
    "text": "Preface"
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "1  Introduction",
    "section": "",
    "text": "Warning\n\n\n\nThis book is a work in progress, please bear with me as I update and fix the issues.\nIf you have any particular examples you’d like to be included please let me know @ c.jonestodd@auckland.ac.nz\n\n\nThe stelfi package fits Hawkes and log-Gaussian Cox Point Process models, with extensions, using Template Model Builder (Kristensen et al. (2016)).\nOverview\nA Hawkes process is a self-exciting temporal point process where the occurrence of an event immediately increases the chance of another (see Hawkes (1971)). stelfi also offers functionality to fit self-inhibiting process and a non-homogeneous background rate.\nA log-Gaussian Cox process is a Poisson point process where the log-intensity is given by a Gaussian random field. stelfi also offers functionality to extend this to a joint likelihood formulation fitting a marked log-Gaussian Cox model.\nIn addition, the stelfi offers functionality to fit self-exciting spatiotemporal point processes. Models are fitted via maximum likelihood using ‘TMB’ (Template Model Builder) (Kristensen et al. (2016)). Where included 1) random fields are assumed to be Gaussian and are integrated over using the Laplace approximation and 2) a stochastic partial differential equation model, introduced by Lindgren, Rue, and Lindström (2011), is defined for the field(s).\n\n\n\n\nHawkes, AG. 1971. “Spectra of Some Self-Exciting and Mutually Exciting Point Processes.” Biometrika.\n\n\nKristensen, Kasper, Anders Nielsen, Casper W. Berg, Hans Skaug, and Bradley M. Bell. 2016. “TMB: Automatic Differentiation and Laplace Approximation.” Journal of Statistical Software. https://doi.org/10.18637/jss.v070.i05.\n\n\nLindgren, Finn, Håvard Rue, and Johan Lindström. 2011. “An Explicit Link Between Gaussian Fields and Gaussian Markov Random Fields: The Stochastic Partial Differential Equation Approach (with Discussion).” Journal of the Royal Statistical Society B 73 (4): 423–98."
  },
  {
    "objectID": "summary.html",
    "href": "summary.html",
    "title": "4  Key stelfi functions",
    "section": "",
    "text": "Summary of model fitting functions offered listing the key arguments for each.\n\n\n\n\n\n\n\nFunction\nKey arguments\n\n\n\n\nfit_hawkes()\n\ntimes - a vector of numeric occurrence times.\nparameters - a vector of named starting values for \\(\\mu\\) (mu), \\(\\alpha\\) (alpha), and \\(\\beta\\) (beta).\nmarks - optional, a vector of marks (\\(m(t)\\)).\n\n\n\nfit_mhawkes()\n\ntimes - a vector of numeric occurrence times.\nstream - character vector specifying the stream ID of each observation in times.\nparameters - a vector of named starting values for \\(\\mu\\) (mu), \\(\\alpha\\) (alpha), and \\(\\beta\\) (beta).\n\n\n\nfit_hawkes_cbf()\nAs fit_hawkes() plus\n\nbackground - some assumed time dependent background function \\(\\mu(t)\\).\nbackground_integral - the integral of background.\nbackground_parameters - parameter starting values for \\(\\mu(t)\\).\n\n( \\(^*\\)Note, \\(\\texttt{mu}\\) in parameters will be ignored)\n\n\nfit_lgcp()\n\nlocs - a named data frame of event locations, x, y, and t (optional).\nsf - a polygon of the spatial domain.\nsmesh - a Delaunay triangulation of the spatial domain returned by INLA::inla.mesh.2d().\ntmesh - optional, a temporal mesh returned by INLA::inla.mesh.1d()).\nparameters - a vector of named starting values for \\(\\boldsymbol{\\beta}\\) (beta), | \\(\\text{log}(\\tau)\\) (log_tau), \\(\\text{log}(\\kappa)\\) (log_kappa), and \\(\\textrm{arctan}(\\rho)\\) (atanh_rho, optional).\n\n\n\nfit_mlgcp()\n\nlocs, sf, and smesh - as fit_lgcp().\nmarks - a matrix of marks for each observation of the point pattern.\nparameters - a list of named parameters, as fit_lgcp() plus (betamarks), (betapp), (marks_coefs_pp ).\nmethods - integer(s) specifying mark distribution: 0, Gaussian; 1, Poisson; 2, binomial; 3, gamma.\nstrfixed - fixed structural parameters, depends on mark distribution.\nfields - a binary vector indicating whether there is a new random field for each mark.\n\n\n\nfit_stelfi()\n\ntimes - as fit_hawkes().\nlocs, sf, and smesh - as fit_lgcp().\nparameters - a list of named parameter starting values for \\(\\mu\\) (mu), \\(\\alpha\\) (alpha), \\(\\beta\\) (beta), \\(\\sigma_x\\) (xsigma) \\(\\sigma_y\\) (ysigma), and \\(\\rho\\) (rho).\nGMRF - logical, should a GMRF be included as a latent spatial effect if so \\(\\tau\\) (tau) and \\(\\kappa\\)(kappa) supplied to parameters.\n\n\n\n\n\nSummary of utility and simulation functions listing the key arguments for each.\n\n\n\n\n\n\n\n\nFunction\nKey arguments\nPurpose\n\n\n\n\nget_coefs()\n\nobj - a fitted model object returned by any one of the functions in the Table above\n\nExtract estimated parameter values from a fitted model.\n\n\nget_fields()\nAs fit_lgcp() and\n\nsd - logical, return standard deviation.\n\nExtract estimated mean, or standard deviation, of GMRF(s).\n\n\nget_weights()\n\nmesh - a Delaunay triangulation of the spatial domain returned by INLA::inla.mesh. 2d().\nsf - a polygon of the spatial domain.\n\nCalculate mesh weights.\n\n\nmesh_2_sf()\n\nmesh - a Delaunay triangulation of the spatial domain returned by INLA::inla.mesh. 2d().\n\nTransforms mesh into a sf object.\n\n\nshow_field()\n\nx - a vector of values, one per each smesh node.\nsmesh - as fit_lgcp() .\nsf - as fit_lgcp().\nclip - logical, clip to domain\n\nPlots spatial random field values.\n\n\nshow_hawkes()\n\nobj - a fitted model object returned by fit_hawkes() or fit_hawkes_cbf().\n\nPlot fitted Hawkes model.\n\n\nshow_hawkes_GOF()\n\nobj - as show_hawkes().\nplot - logical\nreturn_values - logical, return compensator values\n\nPlot goodness-of-fit metrics for a Hawkes model.\n\n\nshow_lambda()\nAs fit_lgcp() and\n\nclip - logical, clip to domain\n\nPlot estimated spatial intensity from a fitted log-Gaussian Cox process model.\n\n\nsim_hawkes()\nAs fit_hawkes()\nSimulate a Hawkes process.\n\n\nsim_lgcp()\nAs fit_lgcp()\nSimulate a realisation of a log-Gaussian Cox process."
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Hawkes, AG. 1971. “Spectra of Some Self-Exciting and Mutually\nExciting Point Processes.” Biometrika."
  },
  {
    "objectID": "index.html#installation",
    "href": "index.html#installation",
    "title": "The R package stelfi",
    "section": "Installation",
    "text": "Installation\n\n\n\nOption 1: stelfi is on CRAN\n\ninstall.packages(\"stelfi\")\n\nOption 2: the development version of stelfi package can be installed from GitHub\n\ndevtools::install_github(\"cmjt/stelfi\")\n\n\n\n\n\n\n\nNote\n\n\n\nTo cite stelfi use\n\ncitation(\"stelfi\")\n\nTo cite package 'stelfi' in publications use:\n\n  Jones-Todd C, van Helsdingen A (2023). _stelfi: Hawkes and\n  Log-Gaussian Cox Point Processes Using Template Model Builder_. R\n  package version 1.0.1, <https://github.com/cmjt/stelfi/>.\n\n  Jones-Todd CM, van Helsdingen ABM (2024). \"stelfi: An R package for\n  fitting Hawkes and log-Gaussian Cox point process models.\" _Ecology\n  and Evolution_, *14*, e11005. doi:10.1002/ece3.11005\n  <https://doi.org/10.1002/ece3.11005>.\n\nTo see these entries in BibTeX format, use 'print(<citation>,\nbibtex=TRUE)', 'toBibtex(.)', or set\n'options(citation.bibtex.max=999)'."
  },
  {
    "objectID": "meshmetrics.html",
    "href": "meshmetrics.html",
    "title": "2  Delaunay triangulation metrics",
    "section": "",
    "text": "data(\"horse_mesh\", package = \"stelfi\")\nmetrics <- meshmetrics(horse_mesh)\nstr(metrics)\n\nReturned is an sf object with the following geometric attributes of the user supplied Delaunay triangulation\n\nV1, V2, and V3 corresponding vertices of mesh matches mesh$graph$tv;\nID, numeric triangle id;\nangleA, angleB, and angleC, the interior angles;\ncircumcircle radius, circumradius, circumcircle_R ();\nincircle radius incircle_r (\\(r\\));\ncentroid locations of the circumcircle, circumcenter, (c\\_Ox, c\\_Oy);\ncentroid locations of the incircle, incenter, (i\\_Ox, i\\_Oy);\nthe radius-edge ratio radius_edge \\(\\frac{R}{l_{min}}\\), where \\(l_{min}\\) is the minimum edge length;\nthe radius ratio radius_ratio \\(\\frac{r}{R}\\);\narea, area (\\(A\\));\nquality a measure of “quality” defined as \\(\\frac{4\\sqrt{3}|A|}{\\Sigma_{i = 1}^3 L_i^2}\\), where \\(L_i\\) is the length of edge \\(i\\).\n\n\nA triangle’s circumcircle (circumscribed circle) is the unique circle that passes through each of its three vertices. A triangle’s incircle (inscribed circle) is the largest circle that can be contained within it (i.e., touches it’s three edges).\nTo plot each triangle’s metric of choice simply change the fill aesthetic. Simply a tool to identify “bad” triangles in the mesh.\n\nggplot(metrics, aes(fill = area)) +\n    geom_sf() + theme_void()\n\n\nggplot(metrics, aes(fill = radius_edge)) +\n    geom_sf() + theme_void()\n\n\nggplot(metrics, aes(fill = quality)) +\n    geom_sf() + theme_void()"
  },
  {
    "objectID": "data.html#temporal-point-pattern-data",
    "href": "data.html#temporal-point-pattern-data",
    "title": "6  Datasets in stelfi",
    "section": "6.1 Temporal point pattern data",
    "text": "6.1 Temporal point pattern data\n\n## load the tidyverse packages\nlibrary(tidyverse)\n\n\nretweets_niwa\nIn 2019 a NIWA scientist found a working USB in the scat of a leopard seal, they then tweeted about it in the hopes of finding its owner. In this chapter a Hawkes process is fitted to these data.\n\n\nNIWA is searching for the owner of a USB stick found in the poo of a leopard seal… Recognise this video? Scientists analysing the scat of leopard seals have come across an unexpected discovery – a USB stick full of photos & still in working order!  https://t.co/2SZVkm5az4 pic.twitter.com/JLEC8vuHH0— NIWA (@niwa_nz) February 5, 2019\n\n\n\nThe retweets_niwa dataset contains the retweet timestamps for this tweet.\n\ndata(retweets_niwa, package = \"stelfi\")\nhead(retweets_niwa)\n\n[1] \"2019-02-07 06:50:08 UTC\" \"2019-02-07 06:50:08 UTC\"\n[3] \"2019-02-07 06:49:22 UTC\" \"2019-02-07 06:48:48 UTC\"\n[5] \"2019-02-07 06:47:52 UTC\" \"2019-02-07 06:47:42 UTC\"\n\n\n\nggplot(data.frame(time = retweets_niwa), aes(x = time)) + \n  geom_histogram() + ylab(\"Retweet frequency\") + xlab(\"\") +\n  theme_bw()\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\n\n\n\n\n\nuk_serial\nMurder UK documents some of the UKs most infamous multiple murderer cases. The uk_serial dataset contains summary information about the documented cases along with approximate timeframes.\n\ndata(\"uk_serial\", package = \"stelfi\")\nhead(uk_serial)\n\n  number_of_kills       years                           name                aka\n1             300 1995 - 1998             Dr. Harold Shipman          Dr. Death\n2             160 1949 - 1983          Dr. John Bodkin Adams                   \n3              26        1978                 Peter Dinsdale          Bruce Lee\n4              21 1865 - 1872                Mary Ann Cotton                   \n5              16        1828 William Burke and William Hare     Body Snatchers\n6              15 1944 - 1948              John George Haigh Acid Bath Murderer\n  year_start year_end date_of_first_kill population_million\n1       1995     1998            03/1995              58.02\n2       1949     1983            08/1949              50.32\n3       1973       NA            06/1973              56.19\n4       1865     1872            01/1865              24.36\n5       1828       NA            02/1828              15.73\n6       1944     1948            09/1944              49.02\n\n\n\nuk_serial %>%\n  mutate(time =  paste(date_of_first_kill, \"/01\", sep='')) %>%\n  mutate(time = as.Date(time, \"%m/%Y/%d\")) %>%\n  ggplot(aes(x = time)) + \n  geom_histogram() + \n  ylab(\"Frequency of known first kill\") + \n  xlab(\"\") + theme_bw()\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`."
  },
  {
    "objectID": "data.html#spatiotemporal-point-pattern-data",
    "href": "data.html#spatiotemporal-point-pattern-data",
    "title": "6  Datasets in stelfi",
    "section": "6.2 Spatiotemporal point pattern data",
    "text": "6.2 Spatiotemporal point pattern data\nUsing maps to create sf objects of country boundaries:\n\nus <- maps::map(\"usa\", fill = TRUE, plot = FALSE) %>%\n    sf::st_as_sf() %>%\n    sf::st_make_valid()\nnz <- maps::map(\"nz\", fill = TRUE, plot = FALSE) %>%\n    sf::st_as_sf() %>%\n    sf::st_make_valid()\niraq <- maps::map(\"world\", \"Iraq\", fill = TRUE, plot = FALSE) %>%\n     sf::st_as_sf() %>%\n    sf::st_make_valid()\n\n\nsasquatch\nThe Bigfoot Field Researchers Organization (BFRO) documents Bigfoot (Sasquatch) sightings; some data have been collated and packaged in stelfi assasquatch.\n\ndata(\"sasquatch\", package = \"stelfi\")\nsasquatch\n\nSimple feature collection with 972 features and 27 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: -124.5301 ymin: 25.84875 xmax: -70.75587 ymax: 48.9058\nGeodetic CRS:  +proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0\n# A tibble: 972 × 28\n   observed         location_details county state season title date       number\n * <chr>            <chr>            <chr>  <chr> <chr>  <chr> <date>      <dbl>\n 1 \"For the past f… This location i… Shann… Sout… Fall   Repo… 2002-12-04   5173\n 2 \"My family had … East on Route 1… Wayne… New … Fall   Repo… 2003-09-20  26566\n 3 \"While this inc… Ward County, Ju… Ward … Nort… Spring Repo… 2000-04-21    751\n 4 \"(Please see Mi… <NA>             Mount… Nort… Winter Repo… 2004-02-22   8165\n 5 \"I was coming h… forested wetlan… Warre… New … Summer Repo… 2005-12-21  13276\n 6 \"My summer ecol… We were on the … Taos … New … Spring Repo… 2000-05-17   4904\n 7 \"On Aug 26 arou… From Garrison t… McLea… Nort… Summer Repo… 2005-08-27  12562\n 8 \"Foot prints wh… The location wa… McKen… Nort… Winter Repo… 2004-02-26   8130\n 9 \"The following … Georgia Ave. an… Sarpy… Nebr… Summer Repo… 2005-01-06   7809\n10 \"We live near O… (Location withh… Dougl… Nebr… Summer Repo… 2005-08-13  12482\n# ℹ 962 more rows\n# ℹ 20 more variables: classification <chr>, geohash <chr>,\n#   temperature_high <dbl>, temperature_mid <dbl>, temperature_low <dbl>,\n#   dew_point <dbl>, humidity <dbl>, cloud_cover <dbl>, moon_phase <dbl>,\n#   precip_intensity <dbl>, precip_probability <dbl>, precip_type <chr>,\n#   pressure <dbl>, summary <chr>, uv_index <dbl>, visibility <dbl>,\n#   wind_bearing <dbl>, wind_speed <dbl>, year <dbl>, geometry <POINT [°]>\n\n\n\n\n\n\nggplot(sasquatch, aes(x = date)) + geom_histogram(bins = 150) +\n  ylab(\"Frequency of Sasquatch sightings\") + xlab(\"\") +\n  theme_bw()\n\n\n\n\n\nggplot(sasquatch) +  \n  geom_sf(alpha = 0.3) + \n  coord_sf() + \n  geom_sf(data = us, fill = NA) + \n  theme_classic()\n\nCoordinate system already present. Adding new coordinate system, which will\nreplace the existing one.\n\n\n\n\n\n\n\nnz_earthquakes\nGeoNet Quake Search catalogues New Zealand earthquake occurrence; some of these data have been and packaged in stelfi as nz_earthquakes. In this chapter a Hawkes process is fitted to these data.\n\ndata(\"nz_earthquakes\", package = \"stelfi\")\nnz_earthquakes\n\nSimple feature collection with 3824 features and 3 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 169.83 ymin: -44.86892 xmax: 175.6328 ymax: -41.8628\nGeodetic CRS:  +proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0\nFirst 10 features:\n            origintime magnitude     depth                   geometry\n1  2014-12-24 07:46:00  3.208996 13.671875 POINT (172.7133 -43.57944)\n2  2014-12-24 06:43:00  4.109075  5.820312 POINT (172.7204 -43.55752)\n3  2014-12-14 08:53:00  3.240377  5.058594 POINT (172.3641 -43.62563)\n4  2014-12-12 13:37:00  4.459034  9.394531  POINT (172.368 -43.63492)\n5  2014-11-20 08:24:00  3.116447 10.039062 POINT (172.7836 -43.42493)\n6  2014-11-18 14:19:00  3.158710 11.269531  POINT (172.7936 -43.4897)\n7  2014-11-02 06:45:00  3.708697 14.960938 POINT (170.2523 -44.48656)\n8  2014-10-11 22:32:00  3.456145 39.804688 POINT (173.1383 -42.67562)\n9  2014-10-01 20:58:00  3.106894 11.386719 POINT (172.6879 -43.49002)\n10 2014-09-30 15:29:00  3.911931  9.335938 POINT (172.1428 -43.25048)\n\n\n\n\n\n\nggplot(nz_earthquakes, aes(x = origintime)) + geom_histogram(bins = 100) +\n  ylab(\"Frequency of earthquakes\") + xlab(\"\") +\n  theme_bw()\n\n\n\n\n\nggplot(nz_earthquakes) +  \n  geom_sf(alpha = 0.1) + \n  coord_sf() + \n  geom_sf(data = nz, fill = NA) +\n  theme_classic()\n\nCoordinate system already present. Adding new coordinate system, which will\nreplace the existing one.\n\n\n\n\n\n\n\nnz_murders\nThe Homicide Report documents homicides in New Zealand. The nz_murders dataset contains summary information about the documented cases. In this chapter a spatiotemporal self-exciting model is fitted to these data.\n\ndata(\"nz_murders\", package = \"stelfi\")\nnz_murders\n\nSimple feature collection with 967 features and 11 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 167.9161 ymin: -46.96127 xmax: 178.3955 ymax: -34.54022\nGeodetic CRS:  +proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0\nFirst 10 features:\n      sex age   date year                      cause              killer\n1    Male  41  Jan 5 2004                   stabbing              friend\n2    Male  46  Jan 8 2004            pick axe wounds              friend\n3    Male   0 Jan 15 2004 asphyxiation (suffocation)              mother\n4  Female  46  Feb 1 2004         blunt force trauma             partner\n5    Male  10  Feb 2 2004                   stabbing              father\n6  Female   2  Feb 2 2004                   stabbing              father\n7    Male  36  Feb 4 2004                   stabbing partners ex-partner\n8    Male  20  Feb 8 2004                  car crash              friend\n9    Male  29  Feb 8 2004         blunt force trauma           strangers\n10 Female  32 Feb 15 2004         blunt force trauma             husband\n                      name  full_date    month          cause_cat     region\n1           Donald Linwood 2004-01-05  January     Violent weapon Canterbury\n2              James Weeks 2004-01-08  January     Violent weapon Canterbury\n3  Gabriel Harrison-Taylor 2004-01-15  January           Asphyxia   Auckland\n4    Odette Lloyd-Rangiuia 2004-02-01 February Blunt force trauma Canterbury\n5          Te Hau OCarroll 2004-02-02 February     Violent weapon Wellington\n6         Ngamata OCarroll 2004-02-02 February     Violent weapon Wellington\n7          Darryn McRobert 2004-02-04 February     Violent weapon Canterbury\n8           Peretiso Sauni 2004-02-08 February          Car crash   Auckland\n9           Shannon McComb 2004-02-08 February Blunt force trauma Canterbury\n10        Asolelei Sameulu 2004-02-15 February Blunt force trauma   Auckland\n                     geometry\n1  POINT (171.6442 -43.63394)\n2  POINT (172.1305 -43.28563)\n3  POINT (174.8498 -36.92575)\n4  POINT (172.6327 -43.55006)\n5  POINT (175.1195 -40.73297)\n6  POINT (175.1193 -40.73273)\n7  POINT (172.5172 -43.53866)\n8  POINT (174.7335 -36.89708)\n9  POINT (172.6429 -43.54363)\n10 POINT (174.6274 -36.90353)\n\n\n\n\n\n\nggplot(nz_murders, aes(x = full_date)) + geom_histogram(bins = 100) +\n  ylab(\"Frequency of murders\") + xlab(\"\") +\n  theme_bw()\n\nWarning: Removed 8 rows containing non-finite outside the scale range\n(`stat_bin()`).\n\n\n\n\n\n\n\n\n\n\niraq_terrorism\nThe Global Terrorism Database (GTD) documents information on terrorism events worldwide; some of these data have been and packaged in stelfi as iraq_terrorism.\n\ndata(\"iraq_terrorism\", package = \"stelfi\")\niraq_terrorism\n\nSimple feature collection with 4208 features and 16 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 38.92288 ymin: 30.51005 xmax: 47.7781 ymax: 36.92948\nGeodetic CRS:  +proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0\nFirst 10 features:\n      iyear imonth iday country success nkill specificity\n18055  2013      4   18    Iraq    TRUE    28           1\n18109  2013      4   20    Iraq    TRUE     0           1\n18110  2013      4   20    Iraq    TRUE     0           1\n18111  2013      4   20    Iraq    TRUE     0           1\n18864  2013      5   16    Iraq    TRUE     3           1\n18865  2013      5   16    Iraq    TRUE     3           1\n18866  2013      5   16    Iraq    TRUE     2           1\n18867  2013      5   16    Iraq    TRUE     3           1\n19161  2013      5   27    Iraq    TRUE     6           1\n19166  2013      5   27    Iraq    TRUE     1           1\n                                            gname   x_coord   y_coord   z_coord\n18055 Islamic State of Iraq and the Levant (ISIL) 0.5974251 0.5844656 0.5490748\n18109 Islamic State of Iraq and the Levant (ISIL) 0.5997164 0.5864987 0.5443892\n18110 Islamic State of Iraq and the Levant (ISIL) 0.5992751 0.5859289 0.5454876\n18111 Islamic State of Iraq and the Levant (ISIL) 0.5959873 0.5733453 0.5622049\n18864 Islamic State of Iraq and the Levant (ISIL) 0.5974251 0.5844656 0.5490748\n18865 Islamic State of Iraq and the Levant (ISIL) 0.5974251 0.5844656 0.5490748\n18866 Islamic State of Iraq and the Levant (ISIL) 0.5974251 0.5844656 0.5490748\n18867 Islamic State of Iraq and the Levant (ISIL) 0.5876310 0.5507342 0.5927745\n19161 Islamic State of Iraq and the Levant (ISIL) 0.5974251 0.5844656 0.5490748\n19166 Islamic State of Iraq and the Levant (ISIL) 0.5974251 0.5844656 0.5490748\n      popdensity luminosity         tt    utm_x      utm_y\n18055  0.4065874  1.0924644 -0.3210921 333098.1 4007920.00\n18109 -0.3479151  0.2298066 -0.2726546 407264.8 5332968.87\n18110 -0.3479432  0.9717434 -0.3210921 401682.9 5252649.56\n18111 -0.3783331  1.0521158 -0.3210921 405272.2 5344797.97\n18864  0.4065874  1.0924644 -0.3210921 595450.3 4078540.46\n18865  0.4065874  1.0924644 -0.3210921 595450.3 4078540.46\n18866  0.4065874  1.0924644 -0.3210921 723492.7   45579.28\n18867 -0.3665068  1.0924644 -0.3210921 815931.5  435892.29\n19161  0.4065874  1.0924644 -0.3210921 252226.3 3703963.04\n19166  0.4065874  1.0924644 -0.3210921 756886.0 4023175.15\n                       geometry\n18055 POINT (44.37177 33.30357)\n18109  POINT (44.3616 32.98293)\n18110 POINT (44.35484 33.05799)\n18111 POINT (43.89071 34.20842)\n18864 POINT (44.37177 33.30357)\n18865 POINT (44.37177 33.30357)\n18866 POINT (44.37177 33.30357)\n18867 POINT (43.14357 36.35415)\n19161 POINT (44.37177 33.30357)\n19166 POINT (44.37177 33.30357)\n\n\n\n\n\n\niraq_terrorism %>%\n  mutate(date = paste(iday, imonth, iyear, sep = \"/\")) %>%\n  mutate(date = as.Date(date, \"%d/%m/%Y\")) %>%\n  ggplot(., aes(x = date)) + geom_histogram(bins = 150) +\n  ylab(\"Frequency of attacks\") + xlab(\"\") +\n  theme_bw()\n\n\n\n\n\nggplot(iraq_terrorism) +  \n  geom_sf(alpha = 0.3) + \n  coord_sf() + \n  geom_sf(data = iraq, fill = NA) +\n  theme_classic()\n\nCoordinate system already present. Adding new coordinate system, which will\nreplace the existing one."
  },
  {
    "objectID": "data.html#simulated-data",
    "href": "data.html#simulated-data",
    "title": "6  Datasets in stelfi",
    "section": "6.3 Simulated data",
    "text": "6.3 Simulated data\n\nxyt\nIn this chapter a log-Gaussian Cox process is fitted to these data and in this chapter a spatiotemporal selfexciting model is fitted.\n\ndata(\"xyt\", package = \"stelfi\")\nxyt_sf <- sf::st_as_sf(xyt)\nxyt_sf\n\nSimple feature collection with 654 features and 1 field\nGeometry type: GEOMETRY\nDimension:     XY\nBounding box:  xmin: 0 ymin: -2.974928 xmax: 12.56637 ymax: 2.974928\nCRS:           NA\nFirst 10 features:\n    label                           geom\n1  window POLYGON ((10.77117 -2.78183...\n2   point       POINT (6.8074 -2.034423)\n3   point     POINT (7.558362 -2.193865)\n4   point     POINT (8.085083 -2.080938)\n5   point     POINT (8.121308 -2.522357)\n6   point     POINT (8.362448 -2.303117)\n7   point     POINT (9.000749 -2.955328)\n8   point     POINT (9.147803 -2.243146)\n9   point     POINT (9.261744 -2.408326)\n10  point      POINT (8.532312 -2.48986)\n\n\n\nggplot(xyt_sf) + geom_sf(fill = NA) +\n  theme_void()\n\n\n\n\n\n\nmarked\nIn this chapter a marked log-Gaussian Cox process is fitted to these data.\n\ndata(marked, package = \"stelfi\")\nmarked_sf <- sf::st_as_sf(x = marked,\n                        coords = c(\"x\", \"y\"))\nmarked_sf\n\nSimple feature collection with 159 features and 3 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 0.006606752 ymin: 0.006502493 xmax: 2.985087 ymax: 2.938558\nCRS:           NA\nFirst 10 features:\n          m1 m2        m3                     geometry\n1  10.008609  0  9.616468 POINT (0.08935799 0.5756269)\n2   8.730592  0  6.918024     POINT (2.177973 2.90455)\n3  11.330677  0 16.798212    POINT (2.250791 1.024792)\n4  11.338656  0  8.073566    POINT (2.033398 1.038773)\n5   9.395725  0  9.977866   POINT (2.777002 0.4685442)\n6  10.331965  0 10.615245   POINT (0.5988652 2.422233)\n7  10.069787  0 11.268171   POINT (1.541071 0.9307671)\n8   9.717775  0 13.306125    POINT (2.615062 1.064561)\n9  10.071326  0 18.300715   POINT (0.3882139 2.146845)\n10 10.147740  0 16.751740     POINT (1.501552 1.64466)\n\n\n\ndomain <- list(3 * cbind(c(0, 1, 1, 0, 0), c(0, 0, 1, 1, 0))) %>%\n  sf::st_polygon() %>% sf::st_sfc() %>% sf::st_sf(geometry = .)\n\nggplot(marked_sf, aes(col = m1)) + \n  geom_sf() + labs(color = \"Mark\") +\n  scale_color_continuous(type = \"viridis\") +\n  geom_sf(data = domain, fill = NA, inherit.aes = FALSE) +\n  theme_void()\n\n\n\n\n\n\nhorse_mesh\nIn this chapter we illustrate different geometric metrics of this triangulation.\n\ndata(\"horse_mesh\", package = \"stelfi\")\nhorse_mesh_sf <- stelfi::mesh_2_sf(horse_mesh)\nhorse_mesh_sf\n\nSimple feature collection with 396 features and 4 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: -17.96875 ymin: -11.78261 xmax: 17.26563 ymax: 11.65217\nCRS:           NA\nFirst 10 features:\n    V1  V2  V3 ID                       geometry\n1  172  30 186  1 POLYGON ((8.441837 -2.16176...\n2   28 188 162  2 POLYGON ((10.43359 0.913043...\n3  168 186  42  3 POLYGON ((5.818232 -3.05894...\n4  117  57  63  4 POLYGON ((-3.660156 -8.0326...\n5  270 253 121  5 POLYGON ((-8.43636 2.023352...\n6   92 144 169  6 POLYGON ((-8.042969 4.47826...\n7  175 137 240  7 POLYGON ((5.689521 -1.13385...\n8  182 148 111  8 POLYGON ((10.50244 7.199319...\n9  253 169 121  9 POLYGON ((-7.850425 2.87106...\n10  14  15 116 10 POLYGON ((13.3125 11.56522,...\n\n\n\nggplot(horse_mesh_sf) + geom_sf(fill = NA, col = \"black\") +\n  theme_void()"
  },
  {
    "objectID": "univariate-hawkes.html#the-fit_hawkes-function",
    "href": "univariate-hawkes.html#the-fit_hawkes-function",
    "title": "2  Univariate Hawkes",
    "section": "2.1 The fit_hawkes() function",
    "text": "2.1 The fit_hawkes() function\n\nlibrary(stelfi)\nargs(fit_hawkes)\n\nfunction (times, parameters = list(), model = 1, marks = c(rep(1, \n    length(times))), tmb_silent = TRUE, optim_silent = TRUE, \n    ...) \nNULL\n\n\n\n2.1.1 Fitting a Hawkes model\nA NIWA scientist found a working USB in the scat of a leopard seal, they then tweeted about it in the hopes of finding its owner.\n\ndata(retweets_niwa)\nhead(retweets_niwa)\n\n[1] \"2019-02-07 06:50:08 UTC\" \"2019-02-07 06:50:08 UTC\"\n[3] \"2019-02-07 06:49:22 UTC\" \"2019-02-07 06:48:48 UTC\"\n[5] \"2019-02-07 06:47:52 UTC\" \"2019-02-07 06:47:42 UTC\"\n\n\n\n## numeric time stamps\ntimes <- unique(sort(as.numeric(difftime(retweets_niwa ,min(retweets_niwa),units = \"mins\"))))\n\n\n\n\n\n\nObserved counts of retweet times\n\n\n\n\n\nparams <- c(mu = 9, alpha = 3, beta = 10)\nfit <- fit_hawkes(times = times, parameters = params) \n\n\n## print out estimated parameters\npars <- get_coefs(fit)\npars\n\n        Estimate  Std. Error\nmu    0.06328099 0.017783908\nalpha 0.07596531 0.007777899\nbeta  0.07911346 0.008109789\n\n\n\nshow_hawkes(fit)\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\n\n\n\n\nshow_hawkes_GOF(fit)\n\n\n    Asymptotic one-sample Kolmogorov-Smirnov test\n\ndata:  interarrivals\nD = 0.031122, p-value = 0.0001937\nalternative hypothesis: two-sided\n\n\n    Box-Ljung test\n\ndata:  interarrivals\nX-squared = 3.3923, df = 1, p-value = 0.0655\n\n\n\n\n\n\n\n2.1.2 Fitting an inhomogenous Hawkes process\nHere we fit a univariate inhomogenous marked Hawkes process where the conditional intensity function is given by\n\\[\\lambda(t) = \\mu(t) + \\alpha \\Sigma_{i:\\tau_i<t}\\text{exp}(-\\beta * (t-\\tau_i)) \\] The background \\(\\mu(t)\\) is time varying, rather than being constant.\nThe following example uses simulated data.\n\nset.seed(1)\nlibrary(hawkesbow)\n\nLoading required package: Rcpp\n\n\n\nAttaching package: 'hawkesbow'\n\n\nThe following object is masked from 'package:stats':\n\n    residuals\n\n# Simulate a Hawkes process with mu = 1+sin(t), alpha=1, beta =2\ntimes <- hawkesbow::hawkes(1000, fun=function(y) {1+0.5*sin(y)}, M=1.5, repr=0.5, family=\"exp\", rate=2)$p\n\nWe will attempt to recover these parameter values, modelling the background as $ (t) = A + Bsin(t)$. The background will be written as a function of \\(x\\) and \\(y\\), where \\(A = e^x\\) and \\(B= logit(y) e^x\\). This formulation ensures the background is never negative.\n\n## The background function must take a single parameter and the time(s) at which it is evaluated\nbackground <- function(params,times){\n        A = exp(params[[1]])\n        B = stats::plogis(params[[2]]) * A\n        return(A + B*sin(times))\n}\n\n## The background_integral function must take a single parameter and the time at which it is evaluated\nbackground_integral <- function(params,x){\n        A = exp(params[[1]])\n        B = stats::plogis(params[[2]]) * A\n        return((A*x)-B*cos(x))\n}\nparam = list(alpha = 0.5, beta = 1.5)\nbackground_param = list(1,1)\nfit <- fit_hawkes_cbf(times = times, parameters = param, background = background, background_integral = background_integral, background_parameters = background_param)\n\nThe estimated values of \\(A\\) and \\(B\\) respectively are\n\nexp(fit$background_parameters[1])\n\n[1] 1.025526\n\nplogis(fit$background_parameters[2]) * exp(fit$background_parameters[1])\n\n[1] 0.5635566\n\n\nThe estimated values of \\(\\alpha\\) and \\(\\beta\\) respectively are:\n\nab <- get_coefs(fit)[1:2,1]\nab\n\n   alpha     beta \n1.040863 2.179564"
  },
  {
    "objectID": "univariate-hawkes.html#the-sim_hawkes-function",
    "href": "univariate-hawkes.html#the-sim_hawkes-function",
    "title": "2  Univariate Hawkes",
    "section": "2.2 The sim_hawkes() function",
    "text": "2.2 The sim_hawkes() function\n\nargs(sim_hawkes)\n\nfunction (mu, alpha, beta, n = 100, plot = FALSE, seed = 123, \n    method = \"1\") \nNULL\n\n\nmethod = 1\n\nsim <- sim_hawkes(mu = 2, alpha = 0.2, beta = 0.3, plot = TRUE)\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\n\n\nhead(sim)\n\n[1] 0.6231314 0.7420664 0.7986166 2.0856174 2.1293941 2.4093639\n\n\nmethod = 2\n\nsim <- sim_hawkes(mu = 2, alpha = 0.2, beta = 0.3, plot = TRUE, method = 2)\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\n\n\nhead(sim)\n\n[1] 0.6231314 0.7314123 1.1083232 1.1571593 1.1795519 2.2830958\n\n\n\n\n\n\nHawkes, AG. 1971. “Spectra of Some Self-Exciting and Mutually Exciting Point Processes.” Biometrika."
  },
  {
    "objectID": "univariate-hawkes.html#fitting-a-univariate-hawkes-model",
    "href": "univariate-hawkes.html#fitting-a-univariate-hawkes-model",
    "title": "2  Univariate Hawkes",
    "section": "2.2 Fitting a univariate Hawkes model",
    "text": "2.2 Fitting a univariate Hawkes model\n\ndevtools::load_all(\"~/Git/stelfi\")\n\nℹ Loading stelfi\n\n## require(stelfi)\n\nTo fit a univariate Hawkes model in stelfi use the function fit_hawkes() with the following required arguments\n\ntimes - a vector of numeric occurrence times, and\nparameters - a vector of named starting values for \\(\\mu\\) (mu), \\(\\alpha\\) (alpha), and \\(\\beta\\) (beta).\n\nThe function get_coefs() can then be called on the fitted model object to return the estimated parameter values.\n\n2.2.1 A simulated example\nSimulating a realisation of a univariate Hawkes process (see Section 2.1 for more details) with \\(\\mu = 1.3\\), \\(\\alpha = 0.4\\), and \\(\\beta = 1.5\\) (over \\(t \\in [0, 500]\\)).\n\ntimes <- sim_hawkes(mu = 1.3, alpha = 0.4, beta = 1.5, n = 500)\n\n\n## starting values\nsv <- c(mu = 1.3, alpha = 0.4, beta = 1.5)\n## using stelfi\nfit <- fit_hawkes(times = times, parameters = sv)\nstelfi <- get_coefs(fit)\nstelfi\n\n       Estimate Std. Error\nmu    1.3997320  0.1125668\nalpha 0.3737118  0.1207772\nbeta  1.7730216  0.7495558\n\n\nAs a comparison, below emhawkes (Lee (2023)), and hawkesbow (Cheysson (2021)) are used to fit a univariate Hawkes process to the same simulated data.\n\n## benchmark using emhawkes\nrequire(emhawkes)\nh <- new(\"hspec\", mu = sv[1], alpha = sv[2], beta = sv[3])\n## emhawkes requires the inter arrival times to fit the model\ninter <- diff(times)\nfit_em <- hfit(object = h, inter_arrival = inter)\nem <- summary(fit_em)$estimate\nem\n\n        Estimate Std. error   t value      Pr(> t)\nmu1    1.3976553  0.1091437 12.805644 1.524557e-37\nalpha1 0.3683585  0.1380857  2.667608 7.639335e-03\nbeta1  1.7380101  0.8236957  2.110015 3.485708e-02\n\n## bench mark using hawkesbow\nrequire(hawkesbow)\nfit_bow <- mle(events = times, kern = \"Exponential\", end = max(times))\n## use the Hessian to obtain the standard errors from hawkesbow\nbow <- cbind(Estimate = fit_bow$par,\n         \"Std. error\" = -fit_bow$model$ddloglik(times, max(times)) |> solve() |> diag() |> sqrt())\nbow\n\n      Estimate Std. error\n[1,] 1.3998368 0.11238176\n[2,] 0.2107781 0.05814911\n[3,] 1.7724499 0.74877227\n\n\nThe table below gives the estimated parameter values from each of stelfi, emhawkes, and hawkesbow along with the standard errors in brackets. Note that hawkesbow estimates \\(\\frac{\\alpha}{\\beta}\\) rather that \\(\\beta\\) directly, and that the standard errors are computed here using the returned Hessian matrix \\(H\\) (i.e., \\(\\sqrt{\\text{diag}{-(H^{-1})}}\\)).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\(\\mu\\)\n\\(\\alpha\\)\n\\(\\beta\\)\n\\(\\frac{\\alpha}{\\beta}\\)\n\n\n\n\nTRUTH\n1.300\n0.400\n1.500\n0.267\n\n\nstelfi\n1.4 ( 0.113 )\n0.374 ( 0.121 )\n1.773 ( 0.75 )\n-\n\n\nemhawkes\n1.398 ( 0.109 )\n0.368 ( 0.138 )\n1.738 ( 0.824 )\n-\n\n\nhawkesbow\n1.4 ( 0.112 )\n-\n1.772 ( 0.749 )\n0.211 ( 0.058 )\n\n\n\n\n\n\n\n2.2.2 An applied example\nA NIWA scientist found a working USB in the scat of a leopard seal, they then tweeted about it in the hopes of finding its owner1. The dates and times of these tweets and retweets are available in stelfi as retweets_niwa.\n\ndata(retweets_niwa)\n\nThe dates/times need to be numeric and sorted in ascending order (starting a time \\(t = 0\\)). Note too that there can be no simultaneous events.\n\n## numeric time stamps\ntimes <- unique(sort(as.numeric(difftime(retweets_niwa ,min(retweets_niwa),units = \"mins\"))))\n\nThe histogram below shows the observed counts (4772) of unique retweet times from the original tweet (\\(t=0\\)) to the time (just over two days later) that the owner of the USB came forward, t = 3143 mins.\n\n\n\n\n\nTo fit the model chose some starting values for the parameters and supply these along with the numeric times to the function fit_hawkes().\n\nsv <- c(mu = 9, alpha = 3, beta = 10)\nfit <- fit_hawkes(times = times, parameters = sv) \n\n\n## print out estimated parameters\npars <- get_coefs(fit)\npars\n\n        Estimate  Std. Error\nmu    0.06328099 0.017783908\nalpha 0.07596531 0.007777899\nbeta  0.07911346 0.008109789\n\n\nFrom the estimated coefficients above\n\nthe expected (estimated) background rate of sightings (i.e., independent sightings) is \\(\\hat{\\mu}T =\\) 0.063 \\(\\times\\) 3143.02 \\(=\\) 198.89, which indicates that ~199 retweets (from the 4772) were principal retweets and that the remaining were due to self-excitement;\nthe expected number of retweets “triggered” by any one retweet is estimated as \\(\\frac{\\hat{\\alpha}}{\\hat{\\beta}}\\) = 0.96 (note the maximum this can possibly be is 1);\nthe expected number of descendants per retweet is estimated as \\(\\frac{\\hat{\\beta}}{\\hat{\\beta} - \\hat{\\alpha}}\\) = 25.13;\nthe rate of decay for the self-excitement is estimated as \\(\\frac{1}{\\hat{\\beta}}\\) = 12.64, indicating that after ~13 minutes a retweet is likely unrelated2 to the previous retweet.\n\nThe show_hawkes() function can be called on the fitted model object to plot the estimated conditional intensity and the data, top and bottom panels below respectively.\n\nshow_hawkes(fit)"
  },
  {
    "objectID": "univariate-hawkes.html#simulating-from-a-hawkes-model",
    "href": "univariate-hawkes.html#simulating-from-a-hawkes-model",
    "title": "2  Univariate Hawkes",
    "section": "2.2 Simulating from a Hawkes model",
    "text": "2.2 Simulating from a Hawkes model\n\nargs(sim_hawkes)\n\nfunction (mu, alpha, beta, n = 100, plot = FALSE, seed = 123, \n    method = \"1\") \nNULL\n\n\nmethod = 1\n\nsim <- sim_hawkes(mu = 2, alpha = 0.2, beta = 0.3, plot = TRUE)\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\n\n\nhead(sim)\n\n[1] 0.6231314 0.7420664 0.7986166 2.0856174 2.1293941 2.4093639\n\n\nmethod = 2\n\nsim <- sim_hawkes(mu = 2, alpha = 0.2, beta = 0.3, plot = TRUE, method = 2)\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\n\n\nhead(sim)\n\n[1] 0.6231314 0.7314123 1.1083232 1.1571593 1.1795519 2.2830958\n\n\n\n\n\n\nHawkes, AG. 1971. “Spectra of Some Self-Exciting and Mutually Exciting Point Processes.” Biometrika."
  },
  {
    "objectID": "univariate-hawkes.html#simulate-hawkes",
    "href": "univariate-hawkes.html#simulate-hawkes",
    "title": "2  Univariate Hawkes",
    "section": "2.2 Simulating from a Hawkes model",
    "text": "2.2 Simulating from a Hawkes model\n\nargs(sim_hawkes)\n\nfunction (mu, alpha, beta, n = 100, plot = FALSE, seed = 123, \n    method = \"1\") \nNULL\n\n\nmethod = 1\n\nsim <- sim_hawkes(mu = 2, alpha = 0.2, beta = 0.3, plot = TRUE)\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\n\n\nhead(sim)\n\n[1] 0.6231314 0.7420664 0.7986166 2.0856174 2.1293941 2.4093639\n\n\nmethod = 2\n\nsim <- sim_hawkes(mu = 2, alpha = 0.2, beta = 0.3, plot = TRUE, method = 2)\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\n\n\nhead(sim)\n\n[1] 0.6231314 0.7314123 1.1083232 1.1571593 1.1795519 2.2830958\n\n\n\n\n\n\nHawkes, AG. 1971. “Spectra of Some Self-Exciting and Mutually Exciting Point Processes.” Biometrika."
  },
  {
    "objectID": "univariate-hawkes.html#sec-simulate-hawkes",
    "href": "univariate-hawkes.html#sec-simulate-hawkes",
    "title": "2  Univariate Hawkes",
    "section": "2.1 Simulating from a univariate Hawkes model",
    "text": "2.1 Simulating from a univariate Hawkes model\nThe function sim_hawkes() offers two simulation methods for simulating a realisation of a univariate Hawkes process. The default, with method = 1, uses the same method as algorithm 2 in Ogata (1981), simulating until a given time horizon (set by argument n).\n\nsim <- sim_hawkes(mu = 0.5, alpha = 1, beta = 1.5, n = 40, plot = TRUE)\n\n\n\n\nThe second option, setting method = 2, uses an accept/reject framework and the argument n specifies the number of points to simulate (default n = 100).\n\nsim <- sim_hawkes(mu = 0.5, alpha = 1, beta = 1.5, plot = TRUE, method = 2)"
  },
  {
    "objectID": "univariate-hawkes.html#goodness-of-fit-for-a-univariate-hawkes-process",
    "href": "univariate-hawkes.html#goodness-of-fit-for-a-univariate-hawkes-process",
    "title": "2  Univariate Hawkes",
    "section": "2.2 Goodness-of-fit for a univariate Hawkes process",
    "text": "2.2 Goodness-of-fit for a univariate Hawkes process\nThe compensator, \\(\\Lambda(\\tilde{t})\\), of any inhomogeneous Poisson process gives the expected number of events in some defined interval \\([0, \\tilde{t}]\\) is given by\n\\[\\Lambda(\\tilde{t}) = \\int_0^{\\tilde{t}} \\lambda(t) dt.\\]\nThe random change theorem (Daley, Vere-Jones, et al. (2003)) states that if a set of events \\([\\tau_1, ..., \\tau_n]\\) is a realisation from a inhomogeneous Poisson process then \\([\\Lambda(\\tau_1), ..., \\Lambda(\\tau_n)]\\) is a realisation of a homogeneous Poisson process with unit rate. Letting \\(\\delta \\Lambda_{i} = \\Lambda(\\tau_i) - \\Lambda(\\tau_{i-1})\\) for \\(i = 2, ..., N\\) and \\(\\delta \\Lambda_{1} = \\Lambda(\\tau_1)\\), under the theorem above \\(\\delta \\Lambda_{i} \\sim \\text{Exp}(1)\\). Using this result a typical goodness-of-fit test is a Kolmogorov-Smirnov (KS) test (see Daley, Vere-Jones, et al. (2003) for more details) where the KS statistic is a measure of the distance between the empirical distribution of all \\(\\delta \\Lambda_{i}\\) and the CDF of a \\(\\text{Exp}(1)\\) distribution.\nThe compensator differences can be extracted from a fitted model using the compensator_differences() function, and a KS test can be carried out manually:\n\ntimes <- sim_hawkes(mu = 1.3, alpha = 0.4, beta = 1.5, n = 500)\nsv <- c(mu = 2, alpha = 1, beta = 5)\nfit <- fit_hawkes(times = times, parameters = sv)\ncompensator <- compensator_differences(fit)\nstats::ks.test(compensator, \"pexp\")\n\n\n    Asymptotic one-sample Kolmogorov-Smirnov test\n\ndata:  compensator\nD = 0.013855, p-value = 0.9958\nalternative hypothesis: two-sided\n\n\nThis gives no evidence against the compensator vaules coming from a \\(\\text{Exp}(1)\\) distribution.\nAnother goodness-of-fit test is the Box-Ljung (or Ljung–Box) test, which tests for autocorrelation between the consecutive compensator values (i.e., independence/stationarity).\n\nstats::Box.test(compensator, type = \"Ljung\")\n\n\n    Box-Ljung test\n\ndata:  compensator\nX-squared = 0.66599, df = 1, p-value = 0.4145\n\n\nThis gives no evidence against the consecutive compensator values being independently distributed.\nAlternatively, both tests and some diagnostic plots are returned by calling the show_hawkes_GOF() function. The four panels an be interpreted as follows\n\ntop left, plots the compensator values against the observed times, which under a well fitting model should align;\ntop right, a transformed QQ plot, the observed quanties should align with the theoretial quantiles under a well fitting model;\nbottom left, the compensator differences, which under the model are assumed to be \\(\\text{Exp}(1)\\) distributed;\nbottom right, consecutive compensator differences, which should show no obvious pattern (no autocorrelation evident) under a well fitting model.\n\n\nshow_hawkes_GOF(fit)\n\n\n    Asymptotic one-sample Kolmogorov-Smirnov test\n\ndata:  interarrivals\nD = 0.013855, p-value = 0.9958\nalternative hypothesis: two-sided\n\n\n    Box-Ljung test\n\ndata:  interarrivals\nX-squared = 0.66599, df = 1, p-value = 0.4145"
  },
  {
    "objectID": "univariate-hawkes.html#fitting-an-inhomogenous-hawkes-process",
    "href": "univariate-hawkes.html#fitting-an-inhomogenous-hawkes-process",
    "title": "2  Univariate Hawkes",
    "section": "2.3 Fitting an inhomogenous Hawkes process",
    "text": "2.3 Fitting an inhomogenous Hawkes process\nA univariate inhomogenous marked Hawkes process has the conditional intensity function\n\\[\\lambda(t) = \\mu(t) + \\alpha \\Sigma_{i:\\tau_i<t}\\text{exp}(-\\beta * (t-\\tau_i)) \\] The background \\(\\mu(t)\\) is time varying, rather than being constant.\nThe following example uses simulated data.\n\nset.seed(1)\nlibrary(hawkesbow)\n# Simulate a Hawkes process with mu = 1+sin(t), alpha=1, beta =2\ntimes <- hawkesbow::hawkes(1000, fun=function(y) {1+0.5*sin(y)}, M=1.5, repr=0.5, family=\"exp\", rate=2)$p\n\nWe will attempt to recover these parameter values, modelling the background as $ (t) = A + Bsin(t)$. The background will be written as a function of \\(x\\) and \\(y\\), where \\(A = e^x\\) and \\(B= logit(y) e^x\\). This formulation ensures the background is never negative.\n\n## The background function must take a single parameter and the time(s) at which it is evaluated\nbackground <- function(params,times){\n        A = exp(params[[1]])\n        B = stats::plogis(params[[2]]) * A\n        return(A + B*sin(times))\n}\n\n## The background_integral function must take a single parameter and the time at which it is evaluated\nbackground_integral <- function(params,x){\n        A = exp(params[[1]])\n        B = stats::plogis(params[[2]]) * A\n        return((A*x)-B*cos(x))\n}\nparam = list(alpha = 0.5, beta = 1.5)\nbackground_param = list(1,1)\nfit <- fit_hawkes_cbf(times = times, parameters = param, background = background, background_integral = background_integral, background_parameters = background_param)\n\nThe estimated values of \\(A\\) and \\(B\\) respectively are\n\nexp(fit$background_parameters[1])\n\n[1] 1.025526\n\nplogis(fit$background_parameters[2]) * exp(fit$background_parameters[1])\n\n[1] 0.5635566\n\n\nThe estimated values of \\(\\alpha\\) and \\(\\beta\\) respectively are:\n\nab <- get_coefs(fit)[1:2,1]\nab\n\n   alpha     beta \n1.040863 2.179564"
  },
  {
    "objectID": "univariate-hawkes.html#fitting-an-inhomogenous-hawkes-model",
    "href": "univariate-hawkes.html#fitting-an-inhomogenous-hawkes-model",
    "title": "2  Univariate Hawkes",
    "section": "2.4 Fitting an inhomogenous Hawkes model",
    "text": "2.4 Fitting an inhomogenous Hawkes model\nA univariate inhomogenous Hawkes process has \\(\\mu = \\mu(t)\\) in Equation 2.1 (i.e., the baseline is time varying, rather than being constant).\nBelow we simulate data from a Hawkes process with \\(\\mu(t) = [A + B*\\text{sin}(\\frac{2 \\pi t}{365.25})]\\) (with \\(A = 1\\) and \\(B = 0.5\\)) to represent a yearly cycle and self-exciting parameters \\(\\alpha = 1\\) and \\(\\beta = 2\\) using hawkesbow (Cheysson (2021)).\n\nmut <- function(t) {\n 1 + 0.5*sin((2*pi*t)/365.25)\n}\n\n\nset.seed(1)\ntimes <- hawkesbow::hawkes(1000, fun = mut,\n M = 1.5, repr = 0.5, family = \"exp\", rate = 2)$p\n\nTo fit this model in stelfi the function \\(\\mu(t)\\) (background) and its integral \\(\\int_0^t \\mu(y) dy\\) (background_integral) are supplied by the user. To ensure \\(\\mu(t) > 0\\) below \\(\\mu(t)\\) is written as a function of \\(x\\) and \\(y\\), where \\(A = e^x\\) and \\(B = \\text{logit}(y) e^x\\).\n\nbackground <- function(params,t){\n        A = exp(params[[1]])\n        B = stats::plogis(params[[2]]) * A\n        return(A + B*sin((2*pi*t)/365.25))\n}\n\nbackground_integral <- function(params,x){\n        A = exp(params[[1]])\n        B = stats::plogis(params[[2]]) * A\n        return((A*x)-B*cos((2*pi*x)/365.25))\n}\n\nThese functions are then passed to the function fit_hawkes_cbf() alongside the observed times (times) and a list of starting values for both \\(\\mu(t)\\) and the self-exciting components via the argument background_parameters and parameters respectively.\n\nsv = list(alpha = 0.5, beta = 1.5)\nbackground_sv = list(1,1)\nfit <- fit_hawkes_cbf(times = times, parameters = sv,\nbackground = background, background_integral = background_integral, background_parameters = background_sv)\n\nThe estimated values of the the transformed \\(A\\) and \\(B\\) parameters are returned via fit$background_parameters, the code below transforms them back to the original scale.\n\nexp(fit$background_parameters[1])\n\n[1] 1.135523\n\nplogis(fit$background_parameters[2]) * exp(fit$background_parameters[1])\n\n[1] 0.7755937\n\n\nThe estimated values of the self-excitement parameters \\(\\alpha\\) and \\(\\beta\\) are returned by the get_coefs() function as usual. The table below compares the estimated values to the true ones\n\n\n\n\n\n\n\\(A\\)\n\\(B\\)\n\\(\\alpha\\)\n\\(\\beta\\)\n\n\n\n\nTRUTH\n1.000\n0.500\n1.000\n2.000\n\n\nstelfi\n1.136\n0.776\n0.985\n2.198\n\n\n\n\n\nThe function show_hawkes() can be used to show the fitted model.\n\nshow_hawkes(fit)\n\n\n\n\nThe function show_hawkes_GOF() will show/print the model diagnostics discussed in Section 2.3.\n\nshow_hawkes_GOF(fit)\n\n\n    Asymptotic one-sample Kolmogorov-Smirnov test\n\ndata:  interarrivals\nD = 0.018277, p-value = 0.4985\nalternative hypothesis: two-sided\n\n\n    Box-Ljung test\n\ndata:  interarrivals\nX-squared = 28.608, df = 1, p-value = 8.86e-08\n\n\n\n\n\n\n\n\n\nCheysson, Felix. 2021. Hawkesbow: Estimation of Hawkes Processes from Binned Observations. https://CRAN.R-project.org/package=hawkesbow.\n\n\nDaley, Daryl J, David Vere-Jones, et al. 2003. An Introduction to the Theory of Point Processes: Volume i: Elementary Theory and Methods. Springer.\n\n\nHawkes, AG. 1971. “Spectra of Some Self-Exciting and Mutually Exciting Point Processes.” Biometrika.\n\n\nLee, Kyungsub. 2023. Emhawkes: Exponential Multivariate Hawkes Model. https://CRAN.R-project.org/package=emhawkes.\n\n\nOgata, Y. 1981. “On Lewis’ Simulation Method for Point Processes.” IEEE Transactions on Information Theory. https://doi.org/10.1109/TIT.1981.1056305."
  },
  {
    "objectID": "univariate-hawkes.html#sec-gof-hawkes",
    "href": "univariate-hawkes.html#sec-gof-hawkes",
    "title": "2  Univariate Hawkes",
    "section": "2.3 Goodness-of-fit for a univariate Hawkes process",
    "text": "2.3 Goodness-of-fit for a univariate Hawkes process\nThe compensator, \\(\\Lambda(\\tilde{t})\\), of any inhomogeneous Poisson process gives the expected number of events in some defined interval \\([0, \\tilde{t}]\\) is given by\n\\[\\Lambda(\\tilde{t}) = \\int_0^{\\tilde{t}} \\lambda(t) dt.\\]\nThe random change theorem (Daley, Vere-Jones, et al. (2003)) states that if a set of events \\([\\tau_1, ..., \\tau_n]\\) is a realisation from a inhomogeneous Poisson process then \\([\\Lambda(\\tau_1), ..., \\Lambda(\\tau_n)]\\) is a realisation of a homogeneous Poisson process with unit rate. Letting \\(\\delta \\Lambda_{i} = \\Lambda(\\tau_i) - \\Lambda(\\tau_{i-1})\\) for \\(i = 2, ..., N\\) and \\(\\delta \\Lambda_{1} = \\Lambda(\\tau_1)\\), under the theorem above \\(\\delta \\Lambda_{i} \\sim \\text{Exp}(1)\\). Using this result a typical goodness-of-fit test is a Kolmogorov-Smirnov (KS) test (see Daley, Vere-Jones, et al. (2003) for more details) where the KS statistic is a measure of the distance between the empirical distribution of all \\(\\delta \\Lambda_{i}\\) and the CDF of a \\(\\text{Exp}(1)\\) distribution.\nThe compensator differences can be extracted from a fitted model using the compensator_differences() function, and a KS test can be carried out manually:\n\ntimes <- sim_hawkes(mu = 1.3, alpha = 0.4, beta = 1.5, n = 500)\nsv <- c(mu = 2, alpha = 1, beta = 5)\nfit <- fit_hawkes(times = times, parameters = sv)\ncompensator <- compensator_differences(fit)\nstats::ks.test(compensator, \"pexp\")\n\n\n    Asymptotic one-sample Kolmogorov-Smirnov test\n\ndata:  compensator\nD = 0.013855, p-value = 0.9958\nalternative hypothesis: two-sided\n\n\nThis gives no evidence against the compensator values coming from a \\(\\text{Exp}(1)\\) distribution.\nAnother goodness-of-fit test is the Box-Ljung (or Ljung–Box) test, which tests for autocorrelation between the consecutive compensator values (i.e., independence/stationarity).\n\nstats::Box.test(compensator, type = \"Ljung\")\n\n\n    Box-Ljung test\n\ndata:  compensator\nX-squared = 0.66599, df = 1, p-value = 0.4145\n\n\nThis gives no evidence against the consecutive compensator values being independently distributed.\nAlternatively, both tests and some diagnostic plots are returned by calling the show_hawkes_GOF() function. The four panels an be interpreted as follows\n\ntop left, plots the compensator values against the observed times, which under a well fitting model should align;\ntop right, a transformed QQ plot, the observed quantities should align with the theoretical quantiles under a well fitting model;\nbottom left, the compensator differences, which under the model are assumed to be \\(\\text{Exp}(1)\\) distributed;\nbottom right, consecutive compensator differences, which should show no obvious pattern (no autocorrelation evident) under a well fitting model.\n\n\nshow_hawkes_GOF(fit)\n\n\n    Asymptotic one-sample Kolmogorov-Smirnov test\n\ndata:  interarrivals\nD = 0.013855, p-value = 0.9958\nalternative hypothesis: two-sided\n\n\n    Box-Ljung test\n\ndata:  interarrivals\nX-squared = 0.66599, df = 1, p-value = 0.4145"
  },
  {
    "objectID": "marked-hawkes.html",
    "href": "marked-hawkes.html",
    "title": "3  Marked Hawkes",
    "section": "",
    "text": "The conditional intensity function for the marked Hawkes model implemented in stelfi is given by\n\\[\\lambda(t; m(t)) = \\mu + \\alpha \\Sigma_{i:\\tau_i<t}m(\\tau_i)\\text{exp}(-\\beta * (t-\\tau_i)) \\] where \\(\\mu\\) is the background rate of the process and \\(m(t)\\) is the temporal mark. The only difference to Equation 2.1 is now that each event has an associated mark \\(m(\\tau_i)\\) that scales the jump sizes (\\(\\alpha\\)) of the self-exciting component of \\(\\lambda(.)\\).\nSimulating data from the emhawkes package Lee (2023) where the marks (a vector that scale the jump sizes, starting at 0) are integer values \\(\\in [1,4]\\) for \\(t > 0\\) and \\(0\\) for \\(t = 0\\). The parameer values of the conditional intensity are \\(\\mu = 1.3\\), \\(\\alpha = 0.4\\), and \\(\\beta = 1.5\\). The jump sizes for the possible mark values are shown below.\n\n\n\n\n \n  \n    mark \n    jump \n  \n \n\n  \n    1 \n    0.4 \n  \n  \n    2 \n    0.8 \n  \n  \n    3 \n    1.2 \n  \n  \n    4 \n    1.6 \n  \n\n\n\n\n\n\nrequire(emhawkes)\nmu <- 1.3; alpha <- 0.4; beta <-  1.5\nfn_mark <- function( ...){\n    sample(1:4, 1)\n}\nh1 <- new(\"hspec\", mu = mu, alpha = alpha, beta = beta,\n          rmark = fn_mark)\nres <- hsim(h1, size=100)\n\nIn this example, the events are earthquakes and the marks are the Richter magnitude of each earthquake.\n\ndata(\"nz_earthquakes\")\nhead(nz_earthquakes)\nnz_earthquakes <- nz_earthquakes[order(nz_earthquakes$origintime),]\nnz_earthquakes <- nz_earthquakes[!duplicated(nz_earthquakes$origintime),]\ntimes <- nz_earthquakes$origintime\ntimes <- as.numeric(difftime(times , min(times), units = \"mins\"))\nmarks <- nz_earthquakes$magnitude\nparams <- c(mu = 3, alpha = 0.05, beta = 1)\nfit <- fit_hawkes(times = times, parameters = params, marks = marks) \n## print out estimated parameters\npars <- get_coefs(fit)\npars\n\n\nshow_hawkes(fit)\n\n\nshow_hawkes_GOF(fit)\n\n\n\n\n\nLee, Kyungsub. 2023. Emhawkes: Exponential Multivariate Hawkes Model. https://CRAN.R-project.org/package=emhawkes."
  },
  {
    "objectID": "marked-hawkes.html#a-simulated-example",
    "href": "marked-hawkes.html#a-simulated-example",
    "title": "3  Marked Hawkes",
    "section": "3.1 A simulated example",
    "text": "3.1 A simulated example\nSimulating data from the emhawkes package Lee (2023) where the marks (a vector that scale the jump sizes, starting at 0) are integer values \\(\\in [1,4]\\) for \\(t > 0\\) and \\(0\\) for \\(t = 0\\) (see Section 3.2 for how to smulate ussing stelfi). The parameter values of the conditional intensity are \\(\\mu = 1.3\\), \\(\\alpha = 0.4\\), and \\(\\beta = 1.5\\). The jump sizes for the possible mark values are shown below.\n\n\nℹ Loading stelfi\n\n\n\n\n \n  \n    mark \n    jump \n  \n \n\n  \n    1 \n    0.4 \n  \n  \n    2 \n    0.8 \n  \n  \n    3 \n    1.2 \n  \n  \n    4 \n    1.6 \n  \n\n\n\n\n\n\nrequire(emhawkes)\nmu <- 1.3; alpha <- 0.4; beta <-  1.5\nfn_mark <- function( ...){\n    sample(1:4, 1)\n}\nh1 <- new(\"hspec\", mu = mu, alpha = alpha, beta = beta,\n          rmark = fn_mark)\nset.seed(123)\nres <- hsim(h1, size = 100)\n\nTo fit the model in stelfi the fit_hawkes() function is used and the additional optional argument marks supplied.\n\nsv <- c(mu = 1.3, alpha = 0.4, beta = 1.5)\nfit <- fit_hawkes(times = res$arrival, parameters = sv, marks = res$mark)\nget_coefs(fit)\n\n       Estimate Std. Error\nmu    1.1741551 0.25195698\nalpha 0.1008830 0.06935281\nbeta  0.8849185 0.50179668\n\n\nNote the estimated coefficient \\(\\alpha\\) from stelfi equates to \\(\\frac{\\alpha}{\\text{mark}}\\) from emhawkes.\nThe fitted model and diagnostic plots are plotted using show_hawkes() and show_hawkes_GOF().\n\nshow_hawkes(fit)\n\n\n\n\n\nshow_hawkes_GOF(fit)\n\n\n    Exact one-sample Kolmogorov-Smirnov test\n\ndata:  interarrivals\nD = 0.09164, p-value = 0.355\nalternative hypothesis: two-sided\n\n\n    Box-Ljung test\n\ndata:  interarrivals\nX-squared = 0.38285, df = 1, p-value = 0.5361"
  },
  {
    "objectID": "marked-hawkes.html#sec-simulate-marked-hawkes",
    "href": "marked-hawkes.html#sec-simulate-marked-hawkes",
    "title": "3  Marked Hawkes",
    "section": "3.2 Simulating a marked process",
    "text": "3.2 Simulating a marked process\nThe TMB (Kristensen et al. (2016)) templates in stelfi allow you to simulate from a fitted model as below. Including the argument complete = TRUE returns the mark values as well as the event times.\n\nset.seed(435)\nsim <- fit$simulate(complete = TRUE)\n## fit to simulated data\nfit <- fit_hawkes(times = sim$times, parameters = sv, marks = sim$marks)\nget_coefs(fit)\n\n        Estimate Std. Error\nmu    1.42163600  0.1718453\nalpha 0.05375758  0.1802477\nbeta  6.08329941 17.8316136\n\nshow_hawkes(fit)\n\n\n\n\n\n\n\n\nKristensen, Kasper, Anders Nielsen, Casper W. Berg, Hans Skaug, and Bradley M. Bell. 2016. “TMB: Automatic Differentiation and Laplace Approximation.” Journal of Statistical Software. https://doi.org/10.18637/jss.v070.i05.\n\n\nLee, Kyungsub. 2023. Emhawkes: Exponential Multivariate Hawkes Model. https://CRAN.R-project.org/package=emhawkes."
  },
  {
    "objectID": "multi-hawkes.html",
    "href": "multi-hawkes.html",
    "title": "4  Multivariate Hawkes",
    "section": "",
    "text": "A multivariate Hawkes process allows for between- and within-stream self-excitement. In stelfi the conditional intensity for the \\(j^{th}\\) (\\(j = 1, ..., N\\)) stream is given by\n\\[\\lambda(t)^{j*} = \\mu_j + \\Sigma_{k = 1}^N\\Sigma_{i:\\tau_i<t} \\alpha_{jk} e^{(-\\beta_j * (t-\\tau_i))},\\] where \\(j, k \\in (1, ..., N)\\). Here, \\(\\alpha_{jk}\\) is the excitement caused by the \\(k^{th}\\) stream on the \\(j^{th}\\). Therefore, \\(\\boldsymbol{\\alpha}\\) is an \\(N \\times N\\) matrix where the diagonals represent the within-stream excitement and the off-diagonals represent the excitement between streams.\n\n\nℹ Loading stelfi"
  }
]